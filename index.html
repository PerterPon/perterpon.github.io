<!DOCTYPE HTML>

    <html lang="zh-Hans">
  
<head>
  <meta charset="utf-8">
  
  <title>PerterPon</title>
  <meta name="author" content="PerterPon">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="PerterPon"/>

  
    <meta property="og:image" content="undefined"/>
  

  
    <meta http-equiv="Content-Language" content="zh-Hans"/>
  

  <link href="/img/favicon.png" rel="icon">
  
    <link rel="apple-touch-icon" href="/img/apple-icon.png">
    <link rel="apple-touch-icon-precomposed" href="/img/apple-icon.png">
    

  <link rel="alternate" href="/atom.xml" title="PerterPon" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  
  <style type="text/css">
  /* Tim Pietrusky advanced checkbox hack (Android <= 4.1.2) */
body{ -webkit-animation: bugfix infinite 1s; }
@-webkit-keyframes bugfix { from {padding:0;} to {padding:0;} }

  
  <!-- Chinese readability improvements -->
    article {font-weight: 400;letter-spacing: .01rem;}
    article .entry{line-height:2;}
  

  
    article .post-content-index .entry{max-height: 550px; overflow:hidden;}
  
</style>

  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-56202861-1', 'auto');
  ga('send', 'pageview');
 
</script>




  
    <!-- 360 Font and Baidu CDN in China -->
    
      <link href='http://fonts.useso.com/css?family=Open+Sans:300,400|Playball' rel='stylesheet' type='text/css'>
    
  <link href='http://apps.bdimg.com/libs/fontawesome/4.1.0/css/font-awesome.css' rel='stylesheet' type='text/css'>
  <script src="http://libs.baidu.com/jquery/1.11.1/jquery.min.js"></script>
  



</head>


<body>
  <header id="header" class="inner"><div class="padding">
	<div class="alignleft logo">
	  <h1><a href="/">PerterPon</a></h1>
	</div>
	<nav id="main-nav" class="alignright">
		<input type="checkbox" id="toggle" />
		<label for="toggle" class="toggle" data-open="Main Menu" data-close="Close Menu" onclick><i class="fa fa-bars"></i></label>
	  <ul class="menu">
	    
	      <li><a href="/">Home</a></li>
	    
	      <li><a href="/archives">Archives</a></li>
	    
	    
	  </ul>
	</nav>
	<div class="clearfix"></div>
</div>
</header>
  <div id="page-heading-wrap">
  	<div class="inner">
      <div class="padding">
    		
          <h2>Gone With the Wind</h2>
        
      </div>
  	</div>
  </div>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper" class="padding">
  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2018/06/23/strong-type-weak-type/">强类型？弱类型？强类型！</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2018-06-23T07:42:00.000Z">2018-06-23</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">PerterPon</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2018/06/23/strong-type-weak-type/#ds-thread"><span class="ds-thread-count" data-thread-key="2018/06/23/strong-type-weak-type/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="“灵活”的JavaScript"><a href="#“灵活”的JavaScript" class="headerlink" title="“灵活”的JavaScript"></a>“灵活”的<code>JavaScript</code></h2><p>以前我很喜欢<code>JavaScript</code>，并不仅仅是因为他是我吃饭的工具，更多因为他非常灵活，从学校了写多了<code>C++</code>或者<code>Java</code>，遇到各种诡异的编译链接等等的错误，到<code>JavaScript</code>弱类型动态语言，简直就是满地撒欢。</p>
<p>我可以使用各种奇淫巧技，虽然比不上<code>Python</code>，也足够让我用1行代码实现别人3行代码的功能，当时我以同样的功能下代码字符越少越牛逼为荣。</p>
<p>然而慢慢地，别人开始接手我写的代码，包括自己开始看以前自己写的代码，虽然别人有三行代码，但是一眼就看明白了三行代码所表达的意思，而我的一行代码，看了好几分钟才能看明白所表达的意思，有时候还不一定正确，也许需要跑起来才能知道效果，我开始质疑自己的这种行为，比如以下行为：</p>
<ul>
<li><code>~~n</code>， 效果等同于<code>Math.floor( n )</code>，虽然运行更快，但是一眼并不能看出什么意思，而函数<code>Math.floor</code>一眼就能看出什么意思。</li>
<li><code>n === n</code>，效果等同于<code>isNaN( n )</code>，因为<code>NaN</code>并不等于他自己。</li>
<li><code>(![]+[])[+[]]+(![]+[])[+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]</code>甚至包括这种，我还真写过，只是没有这么夸张。</li>
</ul>
<h2 id="灵活的代价"><a href="#灵活的代价" class="headerlink" title="灵活的代价"></a>灵活的代价</h2><p>下面的代码是一个真实的例子，我调用了别人的代码，他的函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function test() &#123;&#10;    ...&#10;&#10;    // &#36825;&#37324;&#36820;&#22238;&#26159;&#19968;&#20010;Promise&#10;    return doSomeAsync();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>返回的是一个<code>Promise</code>，所以我用<code>await</code>去调用，到这里并没有问题。</p>
<p>而出现问题来源于一次需求的增加，在执行这种函数时，需要判断一些意外情况，如果出现意外，就弹出一个对话框，让用户点击确认后才继续执行，于是他的代码变成了: </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;function test( needConfirm ) &#123;&#10;&#10;    ...&#10;&#10;    if ( needConfirm ) &#123;&#10;        Dialog.show( &#123;&#10;            content: &#39;&#24744;&#30830;&#23450;&#35201;&#32487;&#32493;&#25191;&#34892;&#20040;&#65311;&#39;,&#10;            onOk: () =&#62; &#123;&#10;                doSomeAsync();&#10;            &#125;&#10;        &#125; );&#10;        return;&#10;    &#125;&#10;&#10;    // &#36825;&#37324;&#36820;&#22238;&#26159;&#19968;&#20010;Promise&#10;    return doSomeAsync();&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这么改动乍一看也没什么问题，如果需要确认，就弹出一个对话框，给用户确认，当用户点击确认的时候，在回调函数里面执行原本的操作。</p>
<p>而对于我的代码来说，我依赖于<code>doSomeAsync</code>执行的结束，所以，当我任然使用<code>await test( true )</code>去调用时，我的代码就报错了，因为<code>true === needConfirm</code>的时候返回的是<code>undefined</code>，<code>await</code>并不会等待，而是继续执行下面的代码，所以导致了错误的出现。</p>
<h2 id="“束缚”的TypeScript"><a href="#“束缚”的TypeScript" class="headerlink" title="“束缚”的TypeScript"></a>“束缚”的<code>TypeScript</code></h2><p>相信以上的代码绝大部分人都写过，我们再仔细看下，其实上面这段代码的问题在于函数的行为不一致，正常情况是返回一个<code>Promise</code>，而分支情况是返回一个<code>undefined</code>，我们看看在<code>TypeScript</code>下怎么写这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function test( needConfirm: boolean ): Promise&#60;void&#62; &#123;&#10;&#10;    ...&#10;&#10;    if ( true === needConfirm ) &#123;&#10;        Dialog.show( &#123;&#10;            content: &#39;&#24744;&#30830;&#35748;&#35201;&#32487;&#32493;&#25191;&#34892;&#20040;&#65311;&#39;,&#10;            onOk: () =&#62; &#123;&#10;                doSomeAsync();&#10;            &#125;&#10;        &#125; );&#10;        return;&#10;    &#125;&#10;&#10;    return doSomeAsync();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>如果你任然这么写，那么<code>TypeScript</code>的编译阶段就会报错，因为你规定了函数需要返回一个<code>Promise</code>，但是却存在返回<code>undefined</code>的情况，你不得不去修改你的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;functon test( needConfirm: boolean ): Promise&#60;void&#62; &#123;&#10;&#10;    ...&#10;&#10;    if ( true === needConfirm ) &#123;&#10;&#10;        let resolveFunc = null;&#10;&#10;        Dialog.show( &#123;&#10;            content: &#39;&#24744;&#30830;&#23450;&#35201;&#32487;&#32493;&#25191;&#34892;&#20040;&#65311;&#39;,&#10;            onOk: async function(): Promise&#60;void&#62; &#123;&#10;                const result = await doSomeAsync();&#10;                resolveFunc( result );&#10;            &#125;&#10;        &#125; );&#10;&#10;        return new Promise( ( resolve, reject ) =&#62; &#123;&#10;            resolveFunc = resolve;&#10;        &#125; );&#10;    &#125;&#10;    return doSomeAsync();&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>编译通过，函数行为一致，调用者也无需感知里面的逻辑。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>强类型写起来限制会更多，然而对于代码的可维护性，可运行性都有很大的提升。</p>
<p>现在前端的复杂性提升地非常快，几年前也许前端仅仅只是更多作为展示型页面存在，但是现在的前端已经承载了太多的东西，用户的交互也发生了很大变化，<code>JavaScript</code>也可以写<code>ReactNative</code>的APP，可以写<code>NodeJs</code>服务，可以用<code>NodeWebkit</code>等工具写跨平台的客户端，使用<code>TypeScript</code>严格按照强类型语言去写你的应用，让你的应用具备更高的可读性和可维护性。</p>
<p>当然事事无绝对，还是得看你的场景，杀鸡焉用牛刀，<code>JavaScript</code>自有存在的意义，至少是目前浏览器官方语言，当你的应用重逻辑时，放手用`TypeScript吧。 </p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2018/06/23/strong-type-weak-type/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2018/06/20/protocol-in-typescript/">在typescript中使用delegate来进行解耦</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2018-06-20T11:39:00.000Z">2018-06-20</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">PerterPon</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2018/06/20/protocol-in-typescript/#ds-thread"><span class="ds-thread-count" data-thread-key="2018/06/20/protocol-in-typescript/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="无处不在的耦合"><a href="#无处不在的耦合" class="headerlink" title="无处不在的耦合"></a>无处不在的耦合</h2><p>通常你写的一个React组件，如果需要和别的组件发生交互，那么你会怎么做？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public componentDidMount(): void &#123;&#10;&#9;this.refs.mycom.test();&#10;&#125;&#10;&#10;public render() &#123;&#10;&#9;return (&#10;&#9;&#9;&#60;MyCom ref=&#34;mycom&#34; /&#62;&#10;&#9;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>这种做法相对来说比较普遍，也比较合情合理，那么如果<code>MyCom</code>组件执行了什么操作之后需要通知到父组件呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public onNotify(): void &#123;&#10;&#10;&#125;&#10;&#10;public render() &#123;&#10;&#9;return (&#10;&#9;&#9;&#60;MyCom notify=&#123; this.onNotify.bind( this ) &#125; ref=&#34;mycom&#34; /&#62;&#10;&#9;);&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>很多时候我们会选择传进去一个回调函数，当<code>MyCom</code>需要发送通知的时候再调用<code>props.notify</code>。</p>
<p>虽然这种方式能实现我们的需求，但也仅仅是实现而已，你会发现这种方式并不是很优雅，而且当你的回调函数多了之后，那简直就是噩梦，后来来使用这个组件的人完全不知道需要传哪些回调函数进去，也不知道哪些回调是可选的，哪些是必选的。</p>
<h2 id="protocol"><a href="#protocol" class="headerlink" title="protocol"></a>protocol</h2><p><code>Protocol</code>是<code>Oc</code>里面的概念，类似<code>Java</code>里面的<code>Interface</code>，和<code>TypeScript</code>中的<code>Interface</code>也比较类似，其中有一个用处就是用于两个类之间的通信解耦，而<code>delegate</code>更多的是一种约定俗成的规则，看看具体怎么用:</p>
<p>首先我有一个A类，用</p>
<p>A.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@protocol ADelegate&#10;&#9;- (void) methodFromA;&#10;@end&#10;&#10;@interface A : NSObject&#10;// &#22768;&#26126;&#22996;&#25176;&#21464;&#37327;&#10;@property (assign, nonatomic) id&#60;ADelegate&#62; delegate;&#10;    - (void) test;&#10;@end</span><br></pre></td></tr></table></figure>
<p>A.m</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;// &#22312;A&#31867;&#30340;&#23454;&#29616;&#25991;&#20214;&#37324;&#38754;&#65292;&#22312;&#38656;&#35201;&#36827;&#34892;&#22238;&#35843;&#30340;&#26102;&#20505;&#65292;&#21482;&#38656;&#35201;&#35843;&#29992;&#24403;&#21069;&#23454;&#20363;&#30340;delegate&#23545;&#35937;&#65292;&#32780;&#19981;&#29992;&#29702;&#20250;&#21040;&#24213;&#26159;&#35841;&#35843;&#29992;&#20102;&#33258;&#24049;&#65292;&#32780;&#19988;&#23545;&#26041;&#32943;&#23450;&#23454;&#29616;&#20102;delegate&#25351;&#21521;&#30340;protocol&#10;// &#38656;&#35201;&#30340;&#26102;&#20505;&#35843;&#29992;&#10;[self.delegate methodFromA];</span><br></pre></td></tr></table></figure>
<p>此时，我有一个B类，需要调用A类，同时需要监听回调函数：</p>
<p>B.h</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#34;A.h&#34;&#10;&#10;// &#36825;&#37324;&#23454;&#29616;&#20102;Adelegate Protocol&#10;@interface B : NSObject &#60;ADelegate&#62;&#10;...&#10;@end</span><br></pre></td></tr></table></figure>
<p>B.m </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void) someMethod &#123;&#10;&#9;A *aInstance = [[A alloc] init];&#10;&#9;// &#36825;&#37324;&#25226;&#24403;&#21069;&#23454;&#20363;&#36171;&#20540;&#32473;A&#31867;&#23454;&#20363;&#30340;delegate&#23646;&#24615;&#10;&#9;aInstance.delegate = self;&#9;&#10;&#125;&#10;&#10;// &#23454;&#29616;&#20102;ADelegate&#10;- (void) methodFromA &#123;&#10;&#9;&#24403;A&#31867;&#35843;&#29992;self.delegate.methodFromA&#26102;&#65292;&#23601;&#21487;&#20197;&#22312;&#36825;&#37324;&#25191;&#34892;&#20320;&#33258;&#24049;&#30340;&#20195;&#30721;&#20102;&#10;&#9;// ...&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="TypeScript中的delegate"><a href="#TypeScript中的delegate" class="headerlink" title="TypeScript中的delegate"></a>TypeScript中的delegate</h2><p>上面可以看到其实<code>delegate</code>的使用非常简单，只是一种约定的规则，同时<code>delegate</code>其实也是一种设计模式，在JS中其实也可以使用，只是JS是弱类型语言，无法通过编译器来约束一些行为，所以依赖于<code>TypeScript</code>的强类型，我们也可以来使用一下<code>delegate</code>：</p>
<p>组件A</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export interface ADelegate &#123;&#10;&#9;methodFromA();&#10;&#125;&#10;&#10;export class A extends React.Component&#60;any, any&#62; &#123;&#10;&#9;public delegate: ADelegate;&#10;&#10;&#9;public render() &#123;&#10;&#10;&#9;&#9;// &#35843;&#29992;delegate&#30340;&#26041;&#27861;&#10;&#9;&#9;this.delegate.methodFromA();&#10;&#10;&#9;&#9;return (&#10;&#9;&#9;&#9;&#60;div&#62;&#60;/div&#62;&#10;&#9;&#9;);&#10;&#10;&#9;&#125;&#10;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>组件B</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123; A, ADelegate &#125; from &#39;A&#39;;&#10;&#10;// &#36825;&#37324;&#23454;&#29616;&#20102;Interface: ADelegate&#10;export class B extends React.Component&#60;any, any&#62; implements ADelegate &#123;&#10;&#9;// &#20174;A&#23454;&#29616;&#30340;&#22238;&#35843;&#12290;&#10;&#9;public methodFromA(): void &#123;&#10;&#10;&#9;&#125;&#10;&#10;&#9;public componentDidMount(): void &#123;&#10;&#9;&#9;const aCom: A = &#60;A&#62;this.refs.acom;&#10;&#9;&#9;aCom.delegate = this;&#10;&#9;&#125;&#10;&#10;&#9;public render() &#123;&#10;&#9;&#9;return (&#10;&#9;&#9;&#9;&#60;A ref=&#34;acom&#34; /&#62;&#10;&#9;&#9;);&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>上面的代码可以看到，A组件面向的不是调用他的组件，而是他自己声明的<code>delegate</code>，完全无需关心是谁在调用自己，在什么场景下调用自己</p>
<p>而B组件也完全不用关心A组件的具体实现，只要实现A组件提供的<code>Interface</code>:<code>ADelegate</code>，从中选择自己需要的方法即可，两者实现解耦，面向delegate编程。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2018/06/20/protocol-in-typescript/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2018/02/28/webpack-chunk-id-with-cdn/">webpack的chunk id和cdn缓存之间的爱恨情仇</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2018-02-28T11:49:00.000Z">2018-02-28</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">PerterPon</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2018/02/28/webpack-chunk-id-with-cdn/#ds-thread"><span class="ds-thread-count" data-thread-key="2018/02/28/webpack-chunk-id-with-cdn/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <p>之前项目中引入了一个插件，把webpack的chunk id使用md5代替，使得其无序化，开发环境没有问题，但是在配合CDN使用的时候，却发现每次发布新版本之后，页面直接报错打不开，提示加载某某chunk的时候无法找到，清除缓存之后问题解决，然而把id无序化插件去掉之后就没问题了，看来问题和缓存和chunk id有关。</p>
<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><h3 id="webpack-chunk"><a href="#webpack-chunk" class="headerlink" title="webpack chunk"></a>webpack chunk</h3><p>先说说webpack的chunk是怎么一回事，如下图：</p>
<p><img src="https://img.alicdn.com/tfs/TB1PQuNbgmTBuNjy1XbXXaMrVXa-343-390.png" alt=""></p>
<p>有四个项目文件，分别为：file1.js, file2.js, file3.js, file4.js.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1.js&#10;file2.js&#10;&#10;file3.js&#10;file4.js</span><br></pre></td></tr></table></figure>
<p>其中，<code>file1</code>依赖了<code>file2</code>，<code>file3</code>依赖了<code>file4</code>，在webpack里面，通常情况下一个文件就是一个module，有时候也有一个文件多个module的情况，不过不多见，webpack会给每一个module分配一个id，这个id是自增的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file1.js -&#62; module1, id: 1&#10;file2.js -&#62; module2, id: 2&#10;&#10;file3.js -&#62; module3, id: 3&#10;file4.js -&#62; module4, id: 4</span><br></pre></td></tr></table></figure>
<p>因为<code>file1</code>和<code>file2</code>对于<code>file3</code>和<code>file4</code>都没有什么依赖关系，所以webpack把这四个文件分成了两个<code>chunk</code>，同时分别给了一个id，也是自增的:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunkA: ChunkId1&#10;&#9;-&#62; module1&#10;&#9;-&#62; module2&#10;&#10;chunkB: ChunkId2&#10;&#9;-&#62; module3&#10;&#9;-&#62; module4</span><br></pre></td></tr></table></figure>
<p>一个chunk就对应于webpack打包之后的文件，于是，打包之后我们现在有两个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;file1.js&#10;            filea.hash.js&#10;file2.js&#10;&#10;----------------------------------&#10;&#10;file3.js&#10;            fileb.hash.js&#10;file4.js</span><br></pre></td></tr></table></figure>
<p>两个chunk所对应的打包后的文件名为: <code>${fileName}.${md5}.js</code>.</p>
<h3 id="CDN缓存"><a href="#CDN缓存" class="headerlink" title="CDN缓存"></a>CDN缓存</h3><p>项目中使用了覆盖式的CDN缓存方式，也就是不同发布之间没有版本概念，而是直接覆盖原来的文件，因为文件名中有MD5值，所以只要文件内容改变，那么文件名也就改变。</p>
<p>好处是如果新版本没有变更的文件，可以让浏览器复用之前的缓存，达到最小更新目的。</p>
<h2 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h2><p>原本这一切都运行得不错，直到后来在项目中加入了一个webpack插件，用来做chunk id的无序化，至于加入这个插件的原因，是因为webpack自带的chunk id的生成规则：</p>
<h3 id="webpack-chunk-id生成方式"><a href="#webpack-chunk-id生成方式" class="headerlink" title="webpack chunk id生成方式"></a>webpack chunk id生成方式</h3><p>webpack的chunk id是从1开始自增的，具体有自己的规则，比如根据引用顺序来给chunk id给定一个id，文件内容的改变并不会影响id，只要引用顺序不变，那么即使文件内容如何改变，都不会影响chunk id，多次打包之后的值都是一样的。</p>
<h3 id="chunk-id无序化"><a href="#chunk-id无序化" class="headerlink" title="chunk id无序化"></a>chunk id无序化</h3><p>上面说chunk id从1开始自增，也就是不同项目之间，chunk id可能都是一样的，这就导致跨项目间调用chunk变得困难了，为了解决这个问题，就引入了一个插件，可以让chunk id无序化，实质上就是用MD5值来代替了chunk id。</p>
<h2 id="为何在CDN场景下发布新版本会导致找不到chunk呢？"><a href="#为何在CDN场景下发布新版本会导致找不到chunk呢？" class="headerlink" title="为何在CDN场景下发布新版本会导致找不到chunk呢？"></a>为何在CDN场景下发布新版本会导致找不到chunk呢？</h2><p>把chunk id用MD5值代替，看起来确实没有问题，在版本化的CDN场景下使用或者说在本地开发环境中使用确实是没有问题的，问题出在和覆盖式的CDN同时使用时候的问题。</p>
<h3 id="问题根源"><a href="#问题根源" class="headerlink" title="问题根源"></a>问题根源</h3><p>首先我们看chunka和chunkb打包之后的代码：</p>
<p>chunka:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10;__webpack__require.e( &#39;1&#39; ).then( &#39;....&#39; );&#10;...</span><br></pre></td></tr></table></figure>
<p>chunkb:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpackJsonp([1],&#123;&#10;&#9;...&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>chunka中代码，打包前的代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import( &#39;./file3&#39; );</span><br></pre></td></tr></table></figure>
<p>chunka中需要引用id为<code>1</code>的chunk，然后chunkb的代码中，首先用<code>webpackJsonp</code>方法定义了自己的chunk id为：<code>1</code>，这样，整个代码就联系起来了，也就能正常运行了。</p>
<h3 id="MD5替代chunk-id"><a href="#MD5替代chunk-id" class="headerlink" title="MD5替代chunk id"></a>MD5替代chunk id</h3><p>如果使用MD5来替换原先的chunk id呢？</p>
<p>chunka:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10;__webpack__require.e( &#39;md51&#39; ).then( &#39;....&#39; );&#10;...</span><br></pre></td></tr></table></figure>
<p>chunkb:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpackJsonp([&#39;md51&#39;],&#123;&#10;&#9;...&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>看起来也没什么问题，反正只要引用的chunk id和声明的chunk id对应上就可以了。尝试修改了一些file3的内容，也就是chunkb的内容有了变更之后：</p>
<p>chunka:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...&#10;__webpack__require.e( &#39;md52&#39; ).then( &#39;....&#39; );&#10;...</span><br></pre></td></tr></table></figure>
<p>chunkb:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpackJsonp([&#39;md52&#39;],&#123;&#10;&#9;...&#10;&#125;);</span><br></pre></td></tr></table></figure>
<p>chunkb的chunk id变成了: md52，同时引用和声明的chunk id都能对应上，运行没问题，那么问题出在哪里呢？我们看看webpack生成文件的文件名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;fileName&#125;.$&#123;md5&#125;.js</span><br></pre></td></tr></table></figure>
<p>因为文件名中有MD5值，所以当修改了chunkb之后，那么chunkb对应的文件名肯定就变更了，这个没问题，而chunka其实内容并没有变更，所以chunka的md5没有变化，也就是说chunka的文件名不变。</p>
<p>然而在引入chunk id无序化插件之前，chunkb的内容变化了，chunk id是不会变的，所以chunk b变化之后，打包后的chunka的文件名和内容都是没有变化的，使用浏览器缓存也不会有任何问题。</p>
<h3 id="缓存带来的问题"><a href="#缓存带来的问题" class="headerlink" title="缓存带来的问题"></a>缓存带来的问题</h3><p>chunk id变成MD5之后，chunkb的改变，会导致chunka的文件名没有变，然而chuna的代码其实是变化了的，因为引用chunkb的时候是要填写chunkb的chunk id的，因为chunk b的内容改变，其chunk id也跟着改变，浏览器根据文件名缓存，因为文件名没有变化，所以一直读取的都是以前的文件，也就导致了找不到某某chunk的根源，以前因为内容变化了，chunk id是不会变化的，所以使用并没有问题。</p>
<h3 id="webpack-MD5生成"><a href="#webpack-MD5生成" class="headerlink" title="webpack MD5生成"></a>webpack MD5生成</h3><p>也许你会说chunka的内容其实是变化了，为啥md5没有改变？其实一开始我也是这么想的，后来看过webpack代码之后就知道原因了:</p>
<p><img src="https://img.alicdn.com/tfs/TB19pb_bkyWBuNjy0FpXXassXXa-768-819.png" alt=""></p>
<p>上面是生成hash的事件，而替换代码则远远在这之后，其实之前也猜到个大概，从业务上讲其实chunka的内容并没有任何变更，hash也是不应该改变的。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2018/02/28/webpack-chunk-id-with-cdn/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2018/01/19/typescript-skill/"></a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2018-01-19T08:53:08.000Z">2018-01-19</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">PerterPon</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2018/01/19/typescript-skill/#ds-thread"><span class="ds-thread-count" data-thread-key="2018/01/19/typescript-skill/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="keyof"><a href="#keyof" class="headerlink" title="keyof"></a>keyof</h2><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><h2 id="react-泛型组件继承和使用"><a href="#react-泛型组件继承和使用" class="headerlink" title="react 泛型组件继承和使用"></a>react 泛型组件继承和使用</h2><h2 id="声明文件的使用"><a href="#声明文件的使用" class="headerlink" title="声明文件的使用"></a>声明文件的使用</h2><h2 id="void不能省略"><a href="#void不能省略" class="headerlink" title="void不能省略"></a>void不能省略</h2>
          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2018/01/19/typescript-skill/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/11/24/thinking-of-lazy-load/">最近对于懒加载的一些思考</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-11-24T06:35:00.000Z">2017-11-24</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">PerterPon</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/11/24/thinking-of-lazy-load/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/11/24/thinking-of-lazy-load/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <p>记得我刚毕业那会，前端还是jQuery的天下，没有什么项目是一个jQuery搞不定的，如果有，那就再加个插件。</p>
<p>后来慢慢出现了一些前端模块化工具，直至seajs的出现，把模块化推向了一个高潮，期间听说了gmail前端有44万行的JS代码，也是非常震惊。</p>
<p>现在的前端为了更好的用户体验，更快地适应业务，逻辑正在变得越来越复杂，同时也带来越来越多的问题。</p>
<h2 id="体积臃肿的前端"><a href="#体积臃肿的前端" class="headerlink" title="体积臃肿的前端"></a>体积臃肿的前端</h2><p>使用webpack的同学对下面这张图很熟悉了，一般我们用webpack打出来的包，都会包含一大堆东西，node_modules文件内容甚至能占到90%以上。</p>
<p><img src="https://img.alicdn.com/tfs/TB16QLWksbI8KJjy1zdXXbe1VXa-909-922.png" alt=""></p>
<h3 id="冰山效应"><a href="#冰山效应" class="headerlink" title="冰山效应"></a>冰山效应</h3><p>很多时候，用户打开一个页面，同时也加载了很多在这个页面上并不会运行的代码，甚至是永远都不会运行的代码，页面上的这些代码就像海洋里的冰山，运行的只是海平面上很小一部分，很大一部分在海平面下的代码，仅仅只会拖慢我们首页的打开时间。</p>
<p><img src="https://img.alicdn.com/tfs/TB1GbDfktzJ8KJjSspkXXbF7VXa-1576-832.png" alt=""></p>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p>从有模块化起，貌似就有了按需加载功能，很多工具都提供了按需加载的功能，以webpack为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const&#160;jQuery&#160;=&#160;await&#160;import(&#160;&#39;jQuery&#39;&#160;);&#10;&#160;&#10;const&#160;model&#160;=&#160;await&#160;import(&#160;&#39;./model/data.js&#39;&#160;);</span><br></pre></td></tr></table></figure>
<p>webpack内置函数<code>import</code>很容易就可以实现按需加载的功能，看起来似乎问题就已经解了？然而这只是问题的第一步，仅仅有了按需加载的能力，问题也会随之而来。</p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>按需加载必然会带来一次网络请求，假设一个场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#29992;&#25143;&#28857;&#20987;&#19968;&#20010;&#25353;&#38062;&#65292;&#28982;&#21518;&#36339;&#20986;&#19968;&#20010;&#24377;&#26694;&#12290;</span><br></pre></td></tr></table></figure>
<p>普通情况下，点击按钮之后发生的事情如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#28857;&#20987;&#25353;&#38062;(ms) -&#62; &#28210;&#26579;&#24377;&#26694;(ms)</span><br></pre></td></tr></table></figure>
<p>如果我们把弹框做按需加载，那么点击按钮之后发生的事情如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#28857;&#20987;&#25353;&#38062;(ms) -&#62; &#21152;&#36733;&#24377;&#26694;&#20195;&#30721;(s) -&#62; &#28210;&#26579;&#24377;&#26694;(ms)</span><br></pre></td></tr></table></figure>
<p>中间多了一个步骤，并且是按秒计算的从网络加载代码，点击一个按钮之后需要等待一段时间，才会弹出弹框，用户操作非常不流畅，如果存在大量这种场景，体验或许还不如不用按需加载。</p>
<p>有什么办法能解这个问题么？一种方案是：<code>预加载</code>，请看下图：</p>
<p><img src="https://img.alicdn.com/tfs/TB1AZZjkxPI8KJjSspfXXcCFXXa-1548-1202.png" alt=""></p>
<h3 id="预加载步骤"><a href="#预加载步骤" class="headerlink" title="预加载步骤"></a>预加载步骤</h3><ol>
<li>首先页面上收集用户的点击行为日志。</li>
<li>拿到点击行为日志，得出用户最常用的操作路径，这部分数据在静态打包的时候注入到前端。</li>
<li>每个人的操作路径会有区别，这里可以在前端也记录一份当前用户的点击数据，这里很多时候虽然本地都已经有缓存了，不过提前把缓存加载到内存，也可以节省很多时间。</li>
<li>在浏览器空闲时，按照第二步和第三步的数据计算权重，最终决定加载顺序。</li>
<li>同时，前端可以根据鼠标运动轨迹，实时地来预测下一步可能会加载的内容，作为一个旁路辅助。这里目前并没有想到一个很好的办法。</li>
</ol>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>鉴于目前前端代码普遍存在于CDN的情况，按需加载带来的另外一个非常有优势的地方在于CDN缓存，假设我们有一份<code>jQuery</code>，有两个文件分别依赖了jQuery，情况如下：</p>
<p><strong><em>a.js</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var jQuery = function()&#123; /*jquery&#20195;&#30721;*/ &#125;&#10;&#10;jQuery.query( &#39;xxx&#39; );</span><br></pre></td></tr></table></figure>
<p><strong><em>b.js</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var jQuery = function()&#123; /*jquery&#20195;&#30721;*/ &#125;&#10;&#10;jQuery.query( &#39;xxx&#39; );</span><br></pre></td></tr></table></figure>
<p>用户在打开A页面和B页面的时候，分别需要下载<code>a.js</code>和<code>b.js</code>，这时候重复下载了两份<code>jQuery</code>，即使他们是一样的，同时在用户的磁盘，也缓存了两份<code>jQuery</code>。</p>
<h3 id="按需加载后的CDN缓存"><a href="#按需加载后的CDN缓存" class="headerlink" title="按需加载后的CDN缓存"></a>按需加载后的CDN缓存</h3><p>那么如果我们用按需加载的方式呢？</p>
<p><strong><em><a href="http://cdn.com/jquery.js" target="_blank" rel="external">http://cdn.com/jquery.js</a></em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var jQuery = function()&#123; /*jquery&#20195;&#30721;*/ &#125;</span><br></pre></td></tr></table></figure>
<p><strong><em>a.js</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var jQuery = import( &#39;http://cdn.com/jquery.js&#39; );&#10;&#10;jQuery.query( &#39;xxx&#39; );</span><br></pre></td></tr></table></figure>
<p><strong><em>b.js</em></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var jQuery = import( &#39;http://cdn.com/jquery.js&#39; );&#10;&#10;jQuery.query( &#39;xxx&#39; );</span><br></pre></td></tr></table></figure>
<p><code>jQuery.js</code>只会被下载一次，所有页面如果用的都是一个cdn地址，那么只要用户打开过任何一个页面，之后的页面即使用户从未打开过，<code>jQuery</code>也已经被缓存，这带来的是一个<code>1+1&gt;2</code>的效果。</p>
<h2 id="理想中的按需加载"><a href="#理想中的按需加载" class="headerlink" title="理想中的按需加载"></a>理想中的按需加载</h2><p>最后说一说我理想中的按需加载，看下图：</p>
<p><img src="https://img.alicdn.com/tfs/TB18SAfkvDH8KJjy1XcXXcpdXXa-1986-1182.png" alt=""></p>
<ol>
<li>逻辑层和展示层完全剥离。</li>
<li>用户操作一个页面的顺序，一定是：<ol>
<li>眼睛看到展示层，发现有一个按钮。</li>
<li>大脑告诉你，这个是一个按钮，是可以点击的。</li>
<li>用手控制鼠标去点击按钮。</li>
<li>执行点击按钮之后事情。</li>
</ol>
</li>
<li>首屏加载的时候，我们可以只加载展示层，逻辑层代码一定是在用户点击按钮之后才会执行。</li>
<li>首屏加载完成，利用用户看页面，并点击按钮的时间，预加载逻辑层代码，实现最快速的首屏展示。</li>
</ol>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/11/24/thinking-of-lazy-load/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/09/12/why-MTU-equals-1500/">什么是MTU？为什么MTU值普遍都是1500？</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-09-12T08:01:00.000Z">2017-09-12</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">PerterPon</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/09/12/why-MTU-equals-1500/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/09/12/why-MTU-equals-1500/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <p>大学那会我玩魔兽世界，我的职业是法师，然后经常有朋友找我我带小号，带小号的方式是冲到血色副本里面把所有怪拉到一起，然后一起用AOE技能瞬间杀掉，在学校玩的时候没什么问题，但是放假在家的时候，我发现每次我拉好怪，放技能AOE的那个瞬间，很大概率会掉线，也不是网速问题，当时很多人也遇到同样的问题，看到个帖子说，把自己的MTU改成1480就行了，当时也不知道啥是MTU，就改了，发现还真的可以，就愉快地打游戏去了，多年以后我才知道MTU的重要性。</p>
<h2 id="什么是MTU"><a href="#什么是MTU" class="headerlink" title="什么是MTU"></a>什么是MTU</h2><p>Maximum Transmission Unit，缩写MTU，中文名是：最大传输单元。</p>
<h2 id="这是哪一层网络的概念？"><a href="#这是哪一层网络的概念？" class="headerlink" title="这是哪一层网络的概念？"></a>这是哪一层网络的概念？</h2><p>从下面这个表格中可以看到，在7层网络协议中，MTU是<strong>数据链路层</strong>的概念。MTU限制的是数据链路层的<strong>上层协议</strong>的payload的大小，例如IP，ICMP等。</p>
<table>
<thead>
<tr>
<th>OSI中的层</th>
<th>功能</th>
<th>TCP/IP协议族</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>文件传输，电子邮件，文件服务，虚拟终端</td>
<td>TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</td>
</tr>
<tr>
<td>表示层</td>
<td>数据格式化，代码转换，数据加密</td>
<td>没有协议</td>
</tr>
<tr>
<td>会话层</td>
<td>解除或建立与别的接点的联系</td>
<td>没有协议</td>
</tr>
<tr>
<td>传输层</td>
<td>提供端对端的接口</td>
<td>TCP，UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>为数据包选择路由</td>
<td>IP，ICMP，RIP，OSPF，BGP，IGMP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>传输有地址的帧以及错误检测功能</td>
<td>SLIP，CSLIP，PPP，ARP，RARP，MTU</td>
</tr>
<tr>
<td>物理层</td>
<td>以二进制数据形式在物理媒体上传输数据</td>
<td>ISO2110，IEEE802，IEEE802.2</td>
</tr>
</tbody>
</table>
<h2 id="MTU有什么用？"><a href="#MTU有什么用？" class="headerlink" title="MTU有什么用？"></a>MTU有什么用？</h2><p>举一个最简单的场景，你在家用自己的笔记本上网，用的是路由器，路由器连接电信网络，然后访问了<code>www.baidu.com</code>，从你的笔记本出发的一个以太网数据帧总共经过了以下路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#31508;&#35760;&#26412; -&#62; &#36335;&#30001;&#22120; -&#62; &#30005;&#20449;&#26426;&#25151; -&#62; &#26381;&#21153;&#22120;</span><br></pre></td></tr></table></figure>
<p>其中，每个节点都有一个MTU值，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1500     1500                 1500&#10;&#31508;&#35760;&#26412; -&#62; &#36335;&#30001;&#22120; -&#62; &#30005;&#20449;&#26426;&#25151;  -&#62; &#26381;&#21153;&#22120;</span><br></pre></td></tr></table></figure>
<p>假设现在我把笔记本的MTU最大值设置成了1700，然后发送了一个超大的ip数据包（2000），这时候在以外网传输的时候会被拆成2个包，一个1700，一个300，然后加上头信息进行传输。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1700     1500                1500&#10;&#31508;&#35760;&#26412; -&#62; &#36335;&#30001;&#22120; -&#62; &#30005;&#20449;&#26426;&#25151; -&#62; &#26381;&#21153;&#22120;</span><br></pre></td></tr></table></figure>
<p>路由器接收到了一个1700的帧，发现大于自己设置的最大值：1500，如果IP包DF标志位为1，也就是不允许分包，那么路由器直接就把这个包丢弃了，根本就不会到达电信机房，也就到不了服务器了，所以，到这里我们就会发现，MTU其实就是在每一个节点的管控值，只要是大于这个值的数据帧，要么选择分片，要么直接丢弃。</p>
<h2 id="为什么是1500？"><a href="#为什么是1500？" class="headerlink" title="为什么是1500？"></a>为什么是1500？</h2><p>其实一个标准的以太网数据帧大小是：<code>1518</code>，头信息有14字节，尾部校验和FCS占了4字节，所以真正留给上层协议传输数据的大小就是：1518 - 14 - 4 = 1500，那么，1518这个值又是从哪里来的呢？</p>
<h2 id="假设取一个更大的值"><a href="#假设取一个更大的值" class="headerlink" title="假设取一个更大的值"></a>假设取一个更大的值</h2><p>假设MTU值和IP数据包大小一致，一个IP数据包的大小是：65535，那么加上以太网帧头和为，一个以太网帧的大小就是：<code>65535 + 14 + 4 = 65553</code>，看起来似乎很完美，发送方也不需要拆包，接收方也不需要重组。</p>
<p>那么假设我们现在的带宽是：<code>100Mbps</code>，因为以太网帧是传输中的最小可识别单元，再往下就是0101所对应的光信号了，所以我们的一条带宽同时只能发送一个以太网帧。如果同时发送多个，那么对端就无法重组成一个以太网帧了，在<code>100Mbps</code>的带宽中（假设中间没有损耗），我们计算一下发送这一帧需要的时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( 65553 * 8 ) / ( 100 * 1024 * 1024 ) &#8776; 0.005(s)</span><br></pre></td></tr></table></figure>
<p>在100M网络下传输一帧就需要5ms，也就是说这5ms其他进程发送不了任何数据。如果是早先的电话拨号，网速只有2M的情况下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( 65553 * 8 ) / ( 2 * 1024 * 1024 ) &#8776; 0.100(s)</span><br></pre></td></tr></table></figure>
<p>100ms，这简直是噩梦。其实这就像红绿灯，时间要设置合理，交替通行，不然同一个方向如果一直是绿灯，那么另一个方向就要堵成翔了。</p>
<h2 id="既然大了不行，那设置小一点可以么？"><a href="#既然大了不行，那设置小一点可以么？" class="headerlink" title="既然大了不行，那设置小一点可以么？"></a>既然大了不行，那设置小一点可以么？</h2><p>假设MTU值设置为100，那么单个帧传输的时间，在2Mbps带宽下需要：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( 100 * 8 ) / ( 2 * 1024 * 1024 ) * 1000 &#8776; 5(ms)</span><br></pre></td></tr></table></figure>
<p>时间上已经能接受了，问题在于，不管MTU设置为多少，以太网头帧尾大小是固定的，都是14 + 4，所以在MTU为100的时候，一个以太网帧的传输效率为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( 100 - 14 - 4 ) / 100 = 82%</span><br></pre></td></tr></table></figure>
<p>写成公式就是：<code>( T - 14 - 4 ) / T</code>，当T趋于无穷大的时候，效率接近<code>100%</code>，也就是MTU的值越大，传输效率最高，但是基于上一点传输时间的问题，来个折中的选择吧，既然头加尾是18，那就凑个整来个1500，总大小就是1518，传输效率：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1500 / 1518 =  98.8%</span><br></pre></td></tr></table></figure>
<p>100Mbps传输时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( 1518 * 8 ) / ( 100 * 1024 * 1024 ) * 1000 = 0.11(ms)</span><br></pre></td></tr></table></figure>
<p>2Mbps传输时间：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( 1518 * 8 ) / ( 2 * 1024 * 1024 ) * 1000 = 5.79(ms)</span><br></pre></td></tr></table></figure>
<p>总体上时间都还能接受</p>
<h3 id="最小值被限制在64"><a href="#最小值被限制在64" class="headerlink" title="最小值被限制在64"></a>最小值被限制在64</h3><p>为什么是64呢？</p>
<p>这个其实和以太网帧在半双工下的碰撞有关，感兴趣的同学可以自行去搜索。</p>
<h2 id="在我玩游戏的时候，为什么把MTU改成1480就不卡了？"><a href="#在我玩游戏的时候，为什么把MTU改成1480就不卡了？" class="headerlink" title="在我玩游戏的时候，为什么把MTU改成1480就不卡了？"></a>在我玩游戏的时候，为什么把MTU改成1480就不卡了？</h2><p>路由器默认值大多都是1500，理论上是没有问题的，那为什么我玩游戏的时候改成1480才能流畅呢？原因在于当时我使用的是ADSL上网的方式，ADSL使用的PPPoE协议。</p>
<h3 id="PPPoE"><a href="#PPPoE" class="headerlink" title="PPPoE"></a>PPPoE</h3><p>PPPoE协议介于以太网和IP之间，协议分为两部分，PPP( Point to Point Protocol )和oE( over Ethernet )，也就是以太网上的PPP协议，而PPPoE协议头信息为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| VER(4bit) | TYPE(4bit) | CODE(8bit) | SESSION-ID(16bit) | LENGTH(16bit) |</span><br></pre></td></tr></table></figure>
<p>这里总共是48位，也就是6个字节，那么另外2个字节是什么呢？答案是PPP协议的ID号，占用两个字节，所以在PPPoE环境下，最佳MTU值应该是：1500 - 4 - 2 = 1492。</p>
<h3 id="我的上网方式"><a href="#我的上网方式" class="headerlink" title="我的上网方式"></a>我的上网方式</h3><p>当时我的上网路径如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PC -&#62; &#36335;&#30001;&#22120; -&#62; &#30005;&#20449;</span><br></pre></td></tr></table></figure>
<p>我在路由器进行拨号，然后PC连接路由器进行上网。</p>
<h3 id="最根本原因"><a href="#最根本原因" class="headerlink" title="最根本原因"></a>最根本原因</h3><p>问题就出在路由器拨号，如果是PC拨号，那么PC会进行PPPoE的封装，会按照MTU:1492来进行以太网帧的封装，即使通过路由器，路由器这时候也只是转发而已，不会进行拆包。</p>
<p>而当用路由器拨号时，PC并不知道路由器的通信方式，会以网卡的设置，默认1500的MTU来进行以太网帧的封装，到达路由器时，由于路由器需要进行PPPoE协议的封装，加上8字节的头信息，这样一来，就必须进行拆包，路由器把这一帧的内容拆成两帧发送，一帧是1492，一帧是8，然后分别加上PPPoE的头进行发送。</p>
<p>平时玩游戏不卡，是因为数据量路由器还处理得过来，而当进行群怪AOE的时候，由于短时间数据量过大，路由器处理不过来，就会发生丢包卡顿的情况，也就掉线了。</p>
<p>帖子里面提到的1480，猜测可能是尽量设小一点，避免二次拨号带来的又一次PPPoE的封装，因为时间久远，没办法回到当时的场景再去抓包了。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>1518这个值是考虑到传输效率以及传输时间而折中选择的一个值，并且由于目前网络链路中的节点太多，其中某个节点的MTU值如果和别的节点不一样，就很容易带来拆包重组的问题，甚至会导致无法发送。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/09/12/why-MTU-equals-1500/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/09/04/main-host/">前端如何获取主域名(根域名)</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-09-04T07:01:00.000Z">2017-09-04</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">PerterPon</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/09/04/main-host/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/09/04/main-host/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近项目中需要获取url的主域名，比如<code>www.baidu.com</code>那么就需要获取<code>baidu.com</code>，看似简单，<code>.</code>号分隔，取到最后两位就行，但是坑爹的是有<code>xxx.com.cn</code>这类域名，还有很多日本的域名，类似<code>toei.aichi.jp</code>等，这些都无法通过这种简单的取最后两位的方式来获取，看来只能枚举了。</p>
<h2 id="Public-Suffix-List"><a href="#Public-Suffix-List" class="headerlink" title="Public Suffix List"></a>Public Suffix List</h2><p>这问题肯定是早有人就遇到了，于是各路有识之士已经帮你完整得准备好了一个列表，里面全部都是那些奇葩域名，一些jp域名也是让我长见识了，不知道各位老司机在秋名山飙车的时候有没有见过这些个域名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#31179;&#30000;.jp&#10;&#32676;&#39340;.jp&#10;&#39321;&#24029;.jp&#10;&#39640;&#30693;.jp&#10;&#40165;&#21462;.jp&#10;&#40575;&#20816;&#23798;.jp&#10;// jp geographic type names&#10;// http://jprs.jp/doc/rule/saisoku-1.html&#10;*.kawasaki.jp&#10;*.kitakyushu.jp&#10;*.kobe.jp&#10;*.nagoya.jp&#10;*.sapporo.jp&#10;*.sendai.jp&#10;*.yokohama.jp&#10;!city.kawasaki.jp&#10;!city.kitakyushu.jp&#10;!city.kobe.jp&#10;!city.nagoya.jp&#10;!city.sapporo.jp&#10;!city.sendai.jp&#10;!city.yokohama.jp&#10;// 4th level registration&#10;aisai.aichi.jp</span><br></pre></td></tr></table></figure>
<p>感兴趣的朋友可以看看这个github项目：<a href="https://github.com/wrangr/psl" target="_blank" rel="external">https://github.com/wrangr/psl</a>。</p>
<p>这里有各种主域名的列表：<a href="https://publicsuffix.org/list/public_suffix_list.dat" target="_blank" rel="external">https://publicsuffix.org/list/public_suffix_list.dat</a>.</p>
<p>浏览器其实也有内置类似的东西，用来做域名判断，cookie存储之类的事宜。</p>
<h2 id="pls的问题"><a href="#pls的问题" class="headerlink" title="pls的问题"></a>pls的问题</h2><p>问题看似好像解决了，已经有现成的脚本去获取，但是仔细一看这脚本竟然有将近200K，而我自己的脚本才10K，既然浏览器已经内置了pls，那浏览器有没有暴露内置接口呢？很遗憾，搜索了一下并没有，而且浏览器那么多，即使chrome暴露了，IE肯定没有，等等，刚刚好像我们说到浏览器用来做域名判断，cookie存储，那我们能不能用这类方式间接地去调用内置pls呢？</p>
<h2 id="最终解决方案"><a href="#最终解决方案" class="headerlink" title="最终解决方案"></a>最终解决方案</h2><p>目前想到有两种方式可以间接去调，<code>document.doamin</code>和<code>document.cookie</code>，测试一下就会发现，如果你尝试把当前域名设置为<code>com.cn</code>或者把cookie设置到<code>com.cn</code>上面，浏览器并不会生效，<code>document.domain</code>在第二次设置的时候，firefox会抛错，看来并不是很合适，而且可能多多少少会影响到业务，cookie设置方便，而且清除也方便，上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function getMainHost() &#123;&#10;  let key  = `mh_$&#123;Math.random()&#125;`;&#10;  let keyR = new RegExp( `(^|;)\\s*$&#123;key&#125;=12345` );&#10;  let expiredTime = new Date( 0 );&#10;  let domain = document.domain;&#10;  let domainList = domain.split( &#39;.&#39; );&#10;&#10;  let urlItems   = [];&#10;  // &#20027;&#22495;&#21517;&#19968;&#23450;&#20250;&#26377;&#20004;&#37096;&#20998;&#32452;&#25104;&#10;  urlItems.unshift( domainList.pop() );&#10;  // &#24930;&#24930;&#20174;&#21518;&#24448;&#21069;&#27979;&#35797;&#10;  while( domainList.length ) &#123;&#10;    urlItems.unshift( domainList.pop() );&#10;    let mainHost = urlItems.join( &#39;.&#39; );&#10;    let cookie   = `$&#123;key&#125;=$&#123;12345&#125;;domain=.$&#123;mainHost&#125;`;&#10;&#10;    document.cookie = cookie;&#10;&#10;    //&#22914;&#26524;cookie&#23384;&#22312;&#65292;&#21017;&#35828;&#26126;&#22495;&#21517;&#21512;&#27861;&#10;    if ( keyR.test( document.cookie ) ) &#123;&#10;      document.cookie = `$&#123;cookie&#125;;expires=$&#123;expiredTime&#125;`;&#10;      return mainHost;&#10;    &#125;&#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>拉了差不多几十个pls里面的域名，跑了一下单元测试，没有问题。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/09/04/main-host/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/07/27/ios-summary-1/">iOS大保健 - 基础信息的收集</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-07-27T02:56:00.000Z">2017-07-27</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">PerterPon</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/07/27/ios-summary-1/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/07/27/ios-summary-1/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <p>本文列出了各种iOS的基础信息的获取方式。</p>
<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><ul>
<li>设备型号</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct utsname systemInfo;&#10;uname(&#38;systemInfo);&#10;NSString *platform = [NSString stringWithCString:systemInfo.machine encoding:NSASCIIStringEncoding];</span><br></pre></td></tr></table></figure>
<ul>
<li>操作系统名称</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIDevice *device = [UIDevice currentDevice];&#10;[device systemName];</span><br></pre></td></tr></table></figure>
<ul>
<li>操作系统版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIDevice *device = [UIDevice currentDevice];&#10;[device systemVersion];</span><br></pre></td></tr></table></figure>
<ul>
<li>设备型号，如: iPad，iPod等。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIDevice *device = [UIDevice currentDevice];&#10;[device model];</span><br></pre></td></tr></table></figure>
<ul>
<li>屏幕分辨率</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UIScreen *screen     = [UIScreen mainScreen];&#10;CGSize screenSize    = [[UIScreen mainScreen] bounds].size;&#10;CGFloat scale        = screen.scale;&#10;int screenX          = screenSize.width * scale;&#10;int screenY          = screenSize.height *scale;&#10;NSString *resolution = [NSString stringWithFormat:@&#34;%d*%d&#34;, screenX, screenY];</span><br></pre></td></tr></table></figure>
<ul>
<li>电池电量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIDevice currentDevice].batteryMonitoringEnabled = YES;&#10;[[NSNotificationCenter defaultCenter] addObserverForName:UIDeviceBatteryLevelDidChangeNotification object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification *notification) &#123;&#10;     // Level has changed&#10;     NSLog(@&#34;Battery Level Change&#34;);&#10;     NSLog(@&#34;&#30005;&#27744;&#30005;&#37327;&#65306;%.2f&#34;, [UIDevice currentDevice].batteryLevel);&#10; &#125;];</span><br></pre></td></tr></table></figure>
<h2 id="网络信息"><a href="#网络信息" class="headerlink" title="网络信息"></a>网络信息</h2><p>需要引入库：<code>CoreTelephony.framework</code></p>
<ul>
<li>网络类型，如：WiFi，4G等。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSString *networktype = nil;&#10;NSArray *subviews = [[[[UIApplication sharedApplication] valueForKey:@&#34;statusBar&#34;] valueForKey:@&#34;foregroundView&#34;]subviews];&#10;NSNumber *dataNetworkItemView = nil;&#10;for (id subview in subviews) &#123;&#10;    if([subview isKindOfClass:[NSClassFromString(@&#34;UIStatusBarDataNetworkItemView&#34;) class]]) &#123;&#10;        dataNetworkItemView = subview;&#10;        break;&#10;    &#125;&#10;&#125;&#10;switch ([[dataNetworkItemView valueForKey:@&#34;dataNetworkType&#34;]integerValue]) &#123;&#10;    case 0:&#10;        networktype = @&#34;UNKNOW&#34;;&#10;        break;&#10;    case 1:&#10;        networktype = @&#34;2G&#34;;&#10;        break;&#10;    case 2:&#10;        networktype = @&#34;3G&#34;;&#10;        break;&#10;    case 3:&#10;        networktype = @&#34;4G&#34;;&#10;        break;&#10;    case 4:&#10;        networktype = @&#34;LTE&#34;;&#10;        break;&#10;    case 5:&#10;        networktype = @&#34;Wi-Fi&#34;;&#10;        break;&#10;    default:&#10;        break;&#10;&#125;&#10;return networktype;</span><br></pre></td></tr></table></figure>
<ul>
<li>蜂窝网络类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTTelephonyNetworkInfo *telephonyInfo = [[CTTelephonyNetworkInfo alloc] init];&#10;if ( [telephonyInfo respondsToSelector:@selector(currentRadioAccessTechnology)] ) &#123;&#10;    id radioAccessType = [telephonyInfo performSelector:@selector(currentRadioAccessTechnology)&#10;                                             withObject:nil];&#10;    &#10;    if ( [radioAccessType isKindOfClass:[NSString class]] ) &#123;&#10;        NSString *accessType = (NSString *)radioAccessType;&#10;        if ( [accessType hasPrefix:@&#34;CTRadioAccessTechnology&#34;] &#38;&#38; accessType.length &#62;= 23 ) &#123;&#10;            NSString *accessTypeStr = [accessType substringFromIndex:23];&#10;            return accessTypeStr;&#10;        &#125;&#10;    &#125;&#10;&#125;&#10;    &#10;return @&#34;UNKNOW&#34;;</span><br></pre></td></tr></table></figure>
<ul>
<li>运营商信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CTTelephonyNetworkInfo *telephonyInfo = [[CTTelephonyNetworkInfo alloc] init];&#10;CTCarrier *carrier    = [telephonyInfo subscriberCellularProvider];&#10;NSString *carrierName = [carrier carrierName];&#10;if ( nil != carrierName ) &#123;&#10;    return carrierName;&#10;&#125;&#10;return @&#34;UNKNOW&#34;;</span><br></pre></td></tr></table></figure>
<h2 id="应用状态"><a href="#应用状态" class="headerlink" title="应用状态"></a>应用状态</h2><ul>
<li>APP启动，或者由后台进入前台</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationBecomeActive) name:UIApplicationDidBecomeActiveNotification object:nil];</span><br></pre></td></tr></table></figure>
<ul>
<li>APP从后台进入前台</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationBecomeActive) name:UIApplicationWillEnterForegroundNotification object:nil];</span><br></pre></td></tr></table></figure>
<ul>
<li>APP进入后台</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(applicationEnterBackground) name: UIApplicationDidEnterBackgroundNotification object:nil];</span><br></pre></td></tr></table></figure>
<ul>
<li>APP在前台锁屏</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &#60;notify.h&#62;&#10;#define NotificationLock CFSTR(&#34;com.apple.springboard.lockcomplete&#34;)&#10;#define NotificationChange CFSTR(&#34;com.apple.springboard.lockstate&#34;)&#10;#define NotificationPwdUI CFSTR(&#34;com.apple.springboard.hasBlankedScreen&#34;)&#10;&#10;static void screenLockStateChanged(CFNotificationCenterRef center,void* observer,CFStringRef name,const void* object,CFDictionaryRef userInfo)&#10;&#123;&#10;&#9;NSString* lockstate = (__bridge NSString*)name;&#10;&#9;if ([lockstate isEqualToString:(__bridge  NSString*)NotificationLock]) &#123;&#10;&#9;    NSLog(@&#34;locked.&#34;);&#10;&#9;&#125; else &#123;&#10;&#9;    NSLog(@&#34;lock state changed.&#34;);&#10;&#9;&#125;&#10;&#125;&#10;&#10;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#10;&#123;&#10;&#9;CFNotificationCenterAddObserver(CFNotificationCenterGetDarwinNotifyCenter(), NULL, screenLockStateChanged, NotificationLock, NULL, CFNotificationSuspensionBehaviorDeliverImmediately);&#10;&#9;CFNotificationCenterAddObserver(CFNotificationCenterGetDarwinNotifyCenter(), NULL, screenLockStateChanged, NotificationChange, NULL, CFNotificationSuspensionBehaviorDeliverImmediately);&#10;&#9;return YES;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>APP在后台锁屏，通过循环的方式检测</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void setScreenStateCb()&#10;&#123;&#10;uint64_t locked;&#10;&#10;__block int token = 0;&#10;notify_register_dispatch(&#34;com.apple.springboard.lockstate&#34;,&#38;token,dispatch_get_main_queue(),^(int t)&#123;&#10;&#125;);&#10;&#9;notify_get_state(token, &#38;locked);&#10;&#9;NSLog(@&#34;%d&#34;,(int)locked);&#10;&#125;&#10;&#10;- (void)applicationDidEnterBackground:(UIApplication *)application&#10;&#123;&#10;&#9;while (YES) &#123;&#10;&#9;    setScreenStateCb();&#10;&#9;    sleep(5); // &#24490;&#29615;5s&#10;&#9;&#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前APP的CPU使用率</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kern_return_t kr;&#10;task_info_data_t tinfo;&#10;mach_msg_type_number_t task_info_count;&#10;    &#10;task_info_count = TASK_INFO_MAX;&#10;kr = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)tinfo, &#38;task_info_count);&#10;if (kr != KERN_SUCCESS) &#123;&#10;    return;&#10;&#125;&#10;    &#10;task_basic_info_t      basic_info;&#10;thread_array_t         thread_list;&#10;mach_msg_type_number_t thread_count;&#10;    &#10;thread_info_data_t     thinfo;&#10;mach_msg_type_number_t thread_info_count;&#10;    &#10;thread_basic_info_t basic_info_th;&#10;uint32_t stat_thread = 0; // Mach threads&#10;    &#10;basic_info = (task_basic_info_t)tinfo;&#10;    &#10;// get threads in the task&#10;kr = task_threads(mach_task_self(), &#38;thread_list, &#38;thread_count);&#10;if (kr != KERN_SUCCESS) &#123;&#10;    return;&#10;&#125;&#10;if (thread_count &#62; 0)&#10;    stat_thread += thread_count;&#10;    &#10;long tot_sec = 0;&#10;long tot_usec = 0;&#10;float tot_cpu = 0;&#10;int j;&#10;    &#10;for (j = 0; j &#60; thread_count; j++)&#10;&#123;&#10;    thread_info_count = THREAD_INFO_MAX;&#10;    kr = thread_info(thread_list[j], THREAD_BASIC_INFO,&#10;                     (thread_info_t)thinfo, &#38;thread_info_count);&#10;    if (kr != KERN_SUCCESS) &#123;&#10;        return;&#10;    &#125;&#10;    &#10;    basic_info_th = (thread_basic_info_t)thinfo;&#10;    &#10;    if (!(basic_info_th-&#62;flags &#38; TH_FLAGS_IDLE)) &#123;&#10;        tot_sec = tot_sec + basic_info_th-&#62;user_time.seconds + basic_info_th-&#62;system_time.seconds;&#10;        tot_usec = tot_usec + basic_info_th-&#62;system_time.microseconds + basic_info_th-&#62;system_time.microseconds;&#10;        tot_cpu = tot_cpu + basic_info_th-&#62;cpu_usage / (float)TH_USAGE_SCALE * 100.0;&#10;    &#125;&#10;    &#10;&#125; // for each thread&#10;    &#10;kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));&#10;assert(kr == KERN_SUCCESS);&#10;    &#10;NSLog(@&#34;CPU Usage: %f \n&#34;, tot_cpu);</span><br></pre></td></tr></table></figure>
<ul>
<li>获取当前APP的内存使用情况</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task_basic_info_data_t taskInfo;&#10;mach_msg_type_number_t infoCount = TASK_BASIC_INFO_COUNT;&#10;kern_return_t kernReturn = task_info(mach_task_self(),&#10;                                     TASK_BASIC_INFO, (task_info_t)&#38;taskInfo, &#38;infoCount);&#10;&#10;if(kernReturn != KERN_SUCCESS) &#123;&#10;    return;&#10;&#125;&#10;    &#10;NSLog(@&#34;Memory Usage: %f&#34;, taskInfo.resident_size / 1024.0 / 1024.0);</span><br></pre></td></tr></table></figure>
          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/07/27/ios-summary-1/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/05/21/https-5/">零门槛学习https--(5)常见的https攻击原理</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-05-21T03:09:00.000Z">2017-05-21</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">PerterPon</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/05/21/https-5/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/05/21/https-5/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <p>上一篇：<a href="/2017/05/19/https-4/">零门槛学习https–(4)https协议详解</a></p>
<p>看似毫无破绽的TLS协议，其实也存在着诸多漏洞，主要因为TLS协议太复杂了，复杂的东西必然会出现漏洞，下面我们来看看一些常见的攻击手段有哪些，以及一些攻击实例。</p>
<h2 id="伪造证书"><a href="#伪造证书" class="headerlink" title="伪造证书"></a>伪造证书</h2><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>这是一种中间人攻击，就是伪造网站证书，虽然浏览器会提示访问了不安全的网址，但是大部分对https没什么了解的人基本都会选择忽略问题继续浏览，这是一种简单，成本低，且效果还可以的攻击方式。</p>
<h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><p>打开浏览器设置，如果证书不可信，那么就直接不能访问。这个其实也不能算是TLS的漏洞，只能说是浏览器为了做兼容而没有采取一些强制性措施，或许不久的将来，浏览器默认就会直接拒绝无效证书的连接。</p>
<h2 id="POODLE"><a href="#POODLE" class="headerlink" title="POODLE"></a>POODLE</h2><h3 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>上一章看TLS协议的时候，我们看到，因为要处理兼容性问题，客户端和服务端不得不支持很多种加密套件和TLS或者SSL版本，由此，衍生一个问题就是：一些老久的加密套件或者SSL版本通常在现在的计算能力下安全性没那么高，或者早先的协议是有安全漏洞的，所以，针对SSL降级，还有加密降级攻击就成了一种主流的攻击方式。</p>
<p>POODLE的全称是<code>Padding Oracle On Downgraded Legacy Encryption</code>，由谷歌的工程师在2014年发现了这个问题，问题的主要原因在于分块加密。其原理是：</p>
<p><strong>AES 分块加密在原文内容长度不满足时，会在原文后面填充一些内容，保证每个分块的长度一致，这就是Padding Oracle，也是攻击的关键，因为新版TLS不存在这个问题，所以我们需要对协议进行降级，而降级就是Downgraded Legacy Encryption，所以这也是这个漏洞名称的由来。</strong></p>
<p>协议降级很简单，只要在客户端发送<code>Client Hello</code>消息的时候，把客户端支持的加密套件替换成SSL3.0，如果服务端支持，那么后续连接就会使用SSLV3来进行连接，具体的<code>Padding Oracle</code>攻击原理可以看一下<a href="http://www.freebuf.com/articles/web/15504.html" target="_blank" rel="external">这篇文章</a>，写得非常详细。</p>
<h3 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h3><p>客户端禁用SSLV3协议，服务端也关闭SSLV3的连接。</p>
<h2 id="FREAK"><a href="#FREAK" class="headerlink" title="FREAK"></a>FREAK</h2><p>这个攻击方式可以说到一个很有意思的事情，目前基本主流的加密算法都是由美国开发的，90年代的时候，NSA为了能够监听世界上所有的网络通信，出台了对于软件出口规定，规定只有美国境内能够使用高强度的RSA加密，对于出口国外的软件，最高允许512密钥长度的RSA，高安全级别的加密算法被认为是战争武器而禁止对外出口。2000年之后，美国逐渐放宽了这个限制，目前美国任然有一些带有加密算法和函数的软硬件受到出口管制。</p>
<h3 id="攻击原理-2"><a href="#攻击原理-2" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>由于历史遗留原因，IE6，网景，甚至是手机上的安卓和iOS Safari 浏览器，都支持512密钥长度的RSA加密，这在2015年的时候才被法国工程师发现。据说在当时任然有38%的服务器还支持512长度的密钥，而且讽刺的是，美国一些政府部门网站也存在此漏洞。</p>
<p>攻击者在<code>Client Hello</code>的时候，把高强度的密钥加密算法都剔除掉，留下低强度的算法，如果服务端也支持低强度的加密算法，那么就会选择这一算法。虽然在90年代一般的PC还无法破解512长度密钥，但是目前个人已经完全有能力破解了。</p>
<h3 id="防御方法-2"><a href="#防御方法-2" class="headerlink" title="防御方法"></a>防御方法</h3><p>苹果已经在当时推出相应补丁，而安卓也在后续版本进行了升级。服务端应该禁止低强度加密算法。</p>
<h2 id="HTTPS-Strip"><a href="#HTTPS-Strip" class="headerlink" title="HTTPS Strip"></a>HTTPS Strip</h2><p>也称为SSLStrip，是一种基于社会学的攻击方法，也是中间人攻击的一种，和任何加密方式都无关，和SSL也无关，也是目前为止我成功实施的一种攻击方式。</p>
<h3 id="攻击原理-3"><a href="#攻击原理-3" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>通常，我们在浏览器访问一个网址的时候，会直接输入网址，而不会关注协议，比如我要访问天猫，那么我就会输入：<code>tmall.com</code>，而此时浏览器默认会使用http协议访问，因为浏览器并不知道服务端是否开启了https，所以，攻击者直接劫持http访问，然后自己去访问<code>https://www.tmall.com</code>，并把内容通过http协议返回给浏览器，浏览器成功收到数据，就直接开始渲染页面，浏览器端完全就是访问一个http站点。所以，这种攻击方式就叫做SSL剥离攻击。除了浏览器之外的场景，基本不会受到此攻击的影响。</p>
<h3 id="防御方法-3"><a href="#防御方法-3" class="headerlink" title="防御方法"></a>防御方法</h3><p><a href="https://zh.wikipedia.org/zh-hans/HTTP%E4%B8%A5%E6%A0%BC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8" target="_blank" rel="external">HSTS</a>(HTTP Strict Transport Security)，这是一种浏览器技术，在客户端访问站点的时候，如果检测到当前域名在HSTS列表中，那么直接使用https协议访问，也就不会被攻击者劫持了。那么如何加入HSTS列表呢？在浏览器第一次访问站点的时候，站点可以在http返回头里面来标示是否启用HSTS，还有过期时间。</p>
<p><img src="https://img.alicdn.com/imgextra/i4/99218453/TB2V3vesbVkpuFjSspcXXbSMVXa_!!99218453.png" alt=""></p>
<p><code>这是第一次访问www.taobao.com的场景，http返回头有个：Strict-Transport-Security属性，过期时间是一年。</code></p>
<p><img src="https://img.alicdn.com/imgextra/i3/99218453/TB2Z.rmsbRkpuFjSspmXXc.9XXa_!!99218453.png" alt=""></p>
<p><code>这是第二次访问www.taobao.com时候，因为已经在HSTS列表中，就直接是一个Internal Redirect，不会请求服务端。</code></p>
<p>其实你会发现，浏览器第一次访问网站的时候，也是有可能被劫持的，所以现在有些网址会内置在浏览器的HSTS列表中，防止第一次访问被劫持的情况发生。不久的将来，也许浏览器就默认使用https访问，这种攻击方式也就无法发挥作用了。</p>
<h3 id="攻击实例"><a href="#攻击实例" class="headerlink" title="攻击实例"></a>攻击实例</h3><p>写个脚本就可以检测网站是否开启了HSTS，对于没有开启HSTS的网站都可以发动攻击。以下是我对<code>tmall.com</code>发起的一次http strip的攻击实例。</p>
<p><img src="https://img.alicdn.com/imgextra/i2/99218453/TB2dlQTvZtnpuFjSZFKXXalFFXa_!!99218453.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#19978;&#22270;&#20013;&#30475;&#21040;&#35775;&#38382;tmall.com&#30340;&#36339;&#36716;&#36923;&#36753;&#26159;&#65306;&#10;&#9;tmall.com --302--&#62; www.tmall.com --301--&#62; https://www.tmall.com&#12290;&#10;&#10;301&#36824;&#22909;&#65292;&#29616;&#20195;&#27983;&#35272;&#22120;&#20960;&#20046;&#20250;&#20316;&#20026;&#27704;&#20037;&#32531;&#23384;&#65292;&#36825;&#31181;&#24773;&#20917;&#19979;&#22914;&#26524;&#19981;&#28165;&#38500;&#32531;&#23384;&#65292;&#20854;&#23454;&#36319;HSTS&#25928;&#26524;&#24046;&#19981;&#22810;&#12290;&#10;302&#23601;&#22353;&#20102;&#65292;&#22522;&#26412;&#26159;&#19981;&#20250;&#32531;&#23384;&#30340;&#12290;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.alicdn.com/imgextra/i1/99218453/TB2bYEjshdkpuFjy0FbXXaNnpXa_!!99218453.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#20174;&#19978;&#22270;&#20013;&#25105;&#20204;&#21487;&#20197;&#30475;&#21040;&#36820;&#22238;&#22836;&#20013;&#34429;&#28982;&#21253;&#21547;&#20102;STS&#22836;&#65292;&#20294;&#26159;&#36807;&#26399;&#26102;&#38388;&#20026;0&#10;&#10;&#20063;&#23601;&#26159;&#19981;&#24320;&#21551;HSTS&#65292;&#29992;&#20102;&#19968;&#20010;301&#36339;&#21040;&#20102;https&#31449;&#28857;</span><br></pre></td></tr></table></figure>
<p>下面我开始准备需要的东西，当然一个前提是你要能捕获流量：</p>
<ol>
<li>为了方便我使用本机测试，可以建个DNS服务器，也可以使用更简单的host文件，我选择使用host文件，把<code>tmall.com</code>、<code>www.tmall.com</code>指向<code>127.0.0.1</code>。实际情况中，可以采用ARP欺骗等方式获取局域网流量。</li>
<li>在本机建立一个<code>web server</code>，具体的代码就不贴了，后面贴一些关键代码。</li>
</ol>
<p>好，我们可以开始攻击了，具体步骤如下。</p>
<ol>
<li>首先使用浏览器访问<code>tmall.com</code>，因为没有开启HSTS，浏览器开始用http方式请求<code>tmall.com</code>。</li>
<li>这时候本次请求已经到我的中间人<code>server</code>，然后<code>server</code>使用IP方式访问真实的<code>tmall.com</code>，这里不能用域名，因为域名已经指向本机了。</li>
<li><p>拿到真实<code>tmall.com</code>的返回之后，添加如下代码：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body += &#39;&#60;script&#62;alert( &#39;hello&#39; )&#60;/script&#62;&#39;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回给浏览器，此时，浏览器看起来是这个样子，弹出了hello，并且仔细看会发现https标示没有了，如果不弹出alert，天猫那个具有强烈视觉冲击感的页面，很容易让你忽略https标示没有了这件事。<br> <img src="https://img.alicdn.com/imgextra/i1/99218453/TB2Cvu7v9FmpuFjSZFrXXayOXXa_!!99218453.png" alt="">    </p>
</li>
<li>再进一步看看，点击<code>登陆</code>按钮的跳转逻辑是：<code>&lt;a href=&quot;//:login.tmall.com&quot;&gt;登陆&lt;/a&gt;</code>，没有写死协议，如果写死了协议，在返回内容的时候，手动替换为<code>http</code>即可。登录页同样没有开启HSTS，我们试试看能不能拿到账号密码。简单分析一下天猫登录页，真正账号密码的输入框采用的是<code>login.taobao.com</code>提供的iframe登录框，有二维码和手动输入账号密码两个选项，二维码无能为力了，看看能不能拿到手动输入账号密码时的内容。</li>
<li><p>看了看<code>login.taobao.com</code>，没有写死协议，并且发现同样没有开启HSTS，这就好办了，和<code>tmall.com</code>一样，拦截请求，并在返回内容添加如下代码，插入一个jQuery，并在在输入密码的时候获取输入事件：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">body += &#10; &#34;&#60;script src=\&#34;https://code.jquery.com/jquery-latest.js\&#34;&#62;&#60;/script&#62;&#34; +&#10; &#34;&#60;script&#62;&#34; +&#10;   &#34;$( &#39;#TPL_username_1&#39; ).on( &#39;input&#39;, function ()&#123;&#34; +&#10;     &#34;console.log( this.value );&#34; +&#10;   &#34;&#125; );&#34; + &#10;   &#34;$( &#39;#TPL_password_1&#39; ).on( &#39;input&#39;, function ()&#123;&#34; +&#10;     &#34;console.log( this.value );&#34; +&#10;   &#34;&#125; );&#34; +&#10; &#34;&#60;/script&#62;&#34;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>运行脚本，看看效果：<br> <img src="https://img.alicdn.com/imgextra/i2/99218453/TB2j5WrvZtnpuFjSZFKXXalFFXa_!!99218453.png" alt=""></p>
<p> <code>login.taobao.com</code>竟然是GBK编码的，导致乱码了，这里我懒得转编码了，可以看到左上角其实浏览器已经显示了<code>不安全</code>三个字，同样估计很少有人会看到这几个字。我们尝试输入一下账号密码试试看：<br> <img src="https://img.alicdn.com/imgextra/i4/99218453/TB2Wp7Gsl0lpuFjSszdXXcdxFXa_!!99218453.png" alt=""><br> 已经打印出账号密码，发个请求就能发送到我自己的服务器了，后面再跳回到https站点就神不知鬼不觉了。</p>
</li>
<li><p>总的来说，本次攻击的需要的条件其实是比较多的，首先因为<code>http://www.tmall.com</code>跳转到<code>https://www.tmall.com</code>是301跳转，而chrome等浏览器把301几乎是当做永久缓存来处理的，除非手动清理缓存，当然很多浏览器对301也不缓存，或者重启就没了。其次，默认的登陆方式是二维码登陆，二维码登陆就无法实施此次攻击了。不过基于天猫访问量巨大，符合条件的流量估计也不少，而且<code>http://login.taobao.com</code>跳往https站点是302，也就是不会缓存了，这个有安全隐患。如果某天天猫开启了HSTS，那么这类攻击就几乎无法生效了，毕竟这对天猫来说也就是一个配置项的事。</p>
</li>
</ol>
<h2 id="其他漏洞"><a href="#其他漏洞" class="headerlink" title="其他漏洞"></a>其他漏洞</h2><ol>
<li>完全信任证书漏洞。很多android APP采取了不校验证书的方式，导致中间人攻击非常容易，比如早先的亚马逊官方APP、携程APP等。</li>
<li>Heartbleed。OpenSSL在实现心跳的扩展没有对输入进行适当验证，导致过读，可以读取服务器内存中的内容，即使协议没问题，实现有问题同样也会造成漏洞的产生。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TLS因为比较复杂，所以或多或少总会有些漏洞，TLS也在慢慢地不断完善，因为很多东西基于数学原理，或者某天出现了快速因式分解等的方法，瞬间就可以破解TLS，也有人说美国安全局其实早就已经掌握某些技术能够监听全世界的加密流量了，加密和破解总是在不断地博弈，在博弈过程中进行自我升级，随着技术的发展以及大家对隐私和网络安全越来越关注，相信我们的网络环境一定会变得越来越安全。</p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/05/21/https-5/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>




  <article class="post">
  
  
    <div class="post-content-index">
  
      
        <header>
          <div class="icon"></div>
            
    
      <h1 class="title transition"><a href="/2017/05/19/https-4/">零门槛学习https--(4)https协议详解</a></h1>
    
  
          <ul>
            <li>
              <span class="heading-span">Posted on: </span>
              <time datetime="2017-05-19T15:46:00.000Z">2017-05-19</time>
            </li>
            
              <li>
                <span class="heading-span">By: </span>

                
                  <a href="/">PerterPon</a>
                

              </li>
            
            <li>
              <span class="heading-span">With: </span>
              

                <a href="/2017/05/19/https-4/#ds-thread"><span class="ds-thread-count" data-thread-key="2017/05/19/https-4/" data-count-type="comments"></span></a>
              
          </ul>
        </header>
      
      <div class="entry">
        
          
            <p>上一篇：<a href="/2017/05/19/https-3/">零门槛学习https–(3)https的安全策略</a></p>
<p>https其实就是在TLS之上的http协议，所以各种头信息以及数据格式和http其实都一样，主要区别就在TLS，下面我们来看看TLS是如何工作的。</p>
<p>本章咱们讨论一下TLS的一个整体思路，和一些重要的细节，所有的细节请参看<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="external">RFC文档</a>。</p>
<h2 id="TLS握手"><a href="#TLS握手" class="headerlink" title="TLS握手"></a>TLS握手</h2><p>和TCP的握手一样，TLS在工作之前也需要握手，保证客户端和服务端的正确运行，下面的图片里面包含了TLS握手的整个过程。</p>
<p><img src="https://img.alicdn.com/imgextra/i1/99218453/TB2BiP6o4RDOuFjSZFzXXcIipXa_!!99218453.png" alt=""></p>
<p>下面是一次对<code>https://www.baidu.com</code>请求的TLS握手过程，我们结合上面的图一起来看看整个过程在实际连接中是什么样子的。</p>
<p><img src="https://img.alicdn.com/imgextra/i4/99218453/TB2E90LvC0mpuFjSZPiXXbssVXa_!!99218453.png" alt=""></p>
<h3 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h3><p>和TCP握手一样，客户端首先要告知服务端自己的来意，总共会传递以下信息：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. &#23458;&#25143;&#31471;&#25903;&#25345;&#30340;TLS&#21327;&#35758;&#29256;&#26412;&#65292;&#36825;&#37324;&#20250;&#26377;&#19968;&#20010;list&#65292;&#30446;&#21069;&#20027;&#27969;&#30340;&#26159;TLS1.2&#12290;&#10;2. &#19968;&#20010;&#38543;&#26426;&#25968;&#65292;&#25105;&#20204;&#35760;&#20026;CR&#65292;&#20855;&#20307;&#30340;&#20316;&#29992;&#26159;&#29992;&#26469;&#29983;&#25104;&#23545;&#35805;&#23494;&#38053;&#65292;&#25105;&#20204;&#31245;&#21518;&#20250;&#29992;&#21040;&#12290;&#10;3. &#25903;&#25345;&#30340;&#21152;&#23494;&#26041;&#27861;&#22871;&#20214;&#12290;&#20363;&#22914;&#65306;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA&#65292;&#30001;&#22235;&#20010;&#37096;&#20998;&#32452;&#25104;&#65306;&#10;    1. &#23494;&#38053;&#20132;&#25442;&#31639;&#27861;&#12290;&#29992;&#26469;&#20132;&#25442;&#23545;&#31216;&#21152;&#23494;&#23494;&#38053;&#30340;&#31639;&#27861;&#12290;&#10;    2. &#21152;&#23494;&#31639;&#27861;&#12290;&#23545;&#31216;&#21152;&#23494;&#31639;&#27861;&#65292;&#30495;&#27491;&#30340;&#21152;&#23494;&#36890;&#35759;&#20869;&#23481;&#30340;&#21152;&#23494;&#31639;&#27861;&#12290;&#10;    3. &#25253;&#25991;&#35748;&#35777;&#20449;&#24687;&#30721;&#65288;MAC&#65289;&#31639;&#27861;&#12290;&#23545;&#36890;&#35759;&#20869;&#23481;&#20570;&#19968;&#20010;&#25688;&#35201;&#65292;&#28982;&#21518;&#38468;&#21152;&#21040;&#27599;&#19968;&#27573;&#28040;&#24687;&#23614;&#37096;&#65292;&#10;       &#36825;&#26679;&#26381;&#21153;&#31471;&#23601;&#30693;&#36947;&#28040;&#24687;&#26159;&#21542;&#34987;&#26356;&#25913;&#12290;&#36825;&#19968;&#27493;&#35201;&#38450;&#27490;&#30340;&#26159;&#65306;&#34429;&#28982;&#21152;&#23494;&#20102;&#65292;&#20294;&#26159;&#22914;&#26524;&#20013;&#38388;&#20154;&#38543;&#20415;&#26356;&#25913;&#19968;&#20010;&#23383;&#33410;&#65292;&#10;       &#20063;&#35768;&#35201;&#34920;&#36798;&#30340;&#20869;&#23481;&#23601;&#19981;&#19968;&#26679;&#20102;&#12290;&#10;    4. PRF&#65288;&#20266;&#38543;&#26426;&#20989;&#25968;&#65289;&#12290;&#10;4. &#25903;&#25345;&#30340;&#21387;&#32553;&#26041;&#27861;&#12290;&#10;5. &#25193;&#23637;&#20449;&#24687;&#12290;&#25193;&#23637;&#20449;&#24687;&#20250;&#26377;&#38750;&#24120;&#22810;&#65292;&#31867;&#20284;&#26102;&#38388;&#25139;&#65292;&#22495;&#21517;&#31561;&#31561;&#20449;&#24687;&#65292;&#20855;&#20307;&#30340;&#21487;&#20197;&#21442;&#30475;RFC&#25991;&#26723;&#12290;</span><br></pre></td></tr></table></figure>
<p>有一个扩展信息可以提一下，早先的TLS协议是没有域名信息的，造成一个问题就是，如果服务端采用一些虚拟化技术虚拟了很多主机，每个主机服务不同的域名，这时候有客户端向服务端发出TLS请求，服务端这时候并不知道应该把哪个证书返回，所以为了解决这个问题，在2006年TLS协议加入了域名扩展信息。</p>
<p>所以说，如果你在公司上网，即使你使用了HTTPS，公司依然能够知道你访问是t66y还是115，或者是taobao。有人也向官方指出这会泄露隐私，但是官方认为这是一个低安全级别问题，并且现在还没有什么好的解法，所以这个问题就搁置了。</p>
<p><img src="https://img.alicdn.com/imgextra/i1/99218453/TB2QKg2rHXlpuFjSszfXXcSGXXa_!!99218453.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#32418;&#26694;&#20013;&#20998;&#21035;&#26159;&#65306;&#10;&#10;1. &#23458;&#25143;&#31471;&#38543;&#26426;&#25968;&#65306;CR&#12290;&#10;2. &#26412;&#27425;&#35831;&#27714;&#30340;&#22495;&#21517;&#12290;&#10;3. &#25193;&#23637;&#20449;&#24687;&#65292;&#35201;&#27714;&#26381;&#21153;&#31471;&#30452;&#25509;&#36820;&#22238;&#35777;&#20070;&#30340;&#26657;&#39564;&#32467;&#26524;&#65292;&#26657;&#39564;&#26041;&#24335;&#26159;&#65306;OCSP&#12290;</span><br></pre></td></tr></table></figure>
<h3 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. &#30830;&#35748;TLS&#21327;&#35758;&#30340;&#29256;&#26412;&#65292;&#22914;&#26524;&#23458;&#25143;&#31471;&#30340;&#21327;&#35758;&#26381;&#21153;&#31471;&#19981;&#25903;&#25345;&#30340;&#35805;&#65292;&#26381;&#21153;&#31471;&#20250;&#36873;&#25321;&#20851;&#38381;&#36825;&#20010;&#36830;&#25509;&#12290;&#10;2. &#20174;&#23458;&#25143;&#31471;&#25903;&#25345;&#30340;&#21152;&#23494;&#26041;&#27861;&#20013;&#65292;&#36873;&#25321;&#19968;&#20010;&#21152;&#23494;&#26041;&#24335;&#65292;&#24182;&#21578;&#30693;&#23458;&#25143;&#31471;&#12290;&#10;3. &#29983;&#25104;&#19968;&#20010;&#38543;&#26426;&#25968;&#65292;&#25105;&#20204;&#35760;&#20026;SR&#65292;&#21518;&#32493;&#25105;&#20204;&#20250;&#32467;&#21512;CR&#29983;&#25104;&#23545;&#35805;&#23494;&#38053;&#65292;&#31245;&#21518;&#20250;&#29992;&#21040;&#12290;&#10;4. &#20174;&#23458;&#25143;&#31471;&#25903;&#25345;&#30340;&#21387;&#32553;&#31639;&#27861;&#20013;&#65292;&#36873;&#25321;&#19968;&#20010;&#21387;&#32553;&#31639;&#27861;&#12290;</span><br></pre></td></tr></table></figure>
<p><img src="https://img.alicdn.com/imgextra/i4/99218453/TB20FhBvEdnpuFjSZPhXXbChpXa_!!99218453.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#32418;&#26694;&#20013;&#20869;&#23481;&#20998;&#21035;&#26159;&#65306;&#10;&#10;1. &#26381;&#21153;&#31471;&#38543;&#26426;&#25968;&#65306;SR&#12290;&#10;2. Session Id&#12290;&#36319;SSO&#30340;cookie&#30340;&#27010;&#24565;&#26377;&#28857;&#31867;&#20284;&#65292;&#23601;&#26159;&#24403;&#20320;&#36825;&#27425;&#25569;&#25163;&#25104;&#21151;&#20043;&#21518;&#65292;&#10;   &#19979;&#27425;&#30452;&#25509;&#24102;&#19978;&#36825;&#20010;session Id&#65292;&#22914;&#26524;&#26381;&#21153;&#31471;&#35748;&#20026;&#21512;&#27861;&#65292;&#37027;&#20040;&#23601;&#19981;&#29992;&#20877;&#36827;&#34892;&#25569;&#25163;&#65292;&#10;   &#30452;&#25509;&#21487;&#20197;&#24320;&#22987;&#29992;&#20043;&#21069;&#24050;&#32463;&#21830;&#37327;&#22909;&#30340;&#23545;&#31216;&#21152;&#23494;&#23494;&#38053;&#24320;&#22987;&#36890;&#20449;&#20102;&#12290;&#10;3. &#26381;&#21153;&#31471;&#36873;&#25321;&#30340;&#21152;&#23494;&#22871;&#20214;&#12290;&#10;4. &#26381;&#21153;&#31471;&#35774;&#32622;&#20102;`status_request`&#30340;&#24212;&#31572;&#26631;&#24535;&#20301;&#65292;&#31572;&#24212;&#23458;&#25143;&#31471;&#20250;&#30452;&#25509;&#36820;&#22238;&#26381;&#21153;&#31471;&#35777;&#20070;&#30340;OCSP&#26657;&#39564;&#32467;&#26524;&#12290;</span><br></pre></td></tr></table></figure>
<h3 id="Server-Certificate"><a href="#Server-Certificate" class="headerlink" title="Server Certificate"></a>Server Certificate</h3><p>这一步主要是返回证书链供客户端验证。</p>
<p><img src="https://img.alicdn.com/imgextra/i3/99218453/TB2axozrM0kpuFjSspdXXX4YXXa_!!99218453.png" alt=""></p>
<p>服务端返回了证书链，里面包含三张证书。</p>
<h3 id="Certificate-Status"><a href="#Certificate-Status" class="headerlink" title="[Certificate Status]"></a>[Certificate Status]</h3><p>这一步也是可选的，当<code>Client Hello</code>的时候，客户端会在<code>extension</code>里面要求服务端直接返回证书的校验结果，以加快访问速度，这是TLS的一个扩展，在<a href="https://tools.ietf.org/html/rfc6066#section-8" target="_blank" rel="external">RFC6066</a>中规定了这一个扩展。当然即使客户端要求了，服务端在<code>Server Hello</code>的时候应答了，服务端也可以不返回，这样客户端就要自己去校验了。</p>
<p>服务端会返回OCSP验证的结果，这样，服务端可以缓存OCSP的结果，服务端就无需再次访问OCSP获取证书验证结果，提高客户端的访问速度。</p>
<p>说的直白一点，这一步的作用就是：服务端返回证书给客户端，然后再告诉客户端说，这个证书我已经验证过了，你放心用吧。客户端会选择信任中间证书，直接校验根证书，所以，这里即使被中间人攻击直接返回验证成功，但是因为客户端任然会通过操作系统内置的根证书来进行验证，这一步任然是安全的。</p>
<p><img src="https://img.alicdn.com/imgextra/i2/99218453/TB28GVmrYtlpuFjSspoXXbcDpXa_!!99218453.png" alt=""></p>
<p><code>这里返回了OCSP的结果：successful。</code></p>
<h3 id="Server-Key-Exchange"><a href="#Server-Key-Exchange" class="headerlink" title="[Server Key Exchange]"></a>[Server Key Exchange]</h3><p>这一步也是可选的，取决于双方的加密方法，这里就不得不提到TLS的两种密钥协商方式：</p>
<ol>
<li>TLS_RSA_XXXX。这类算法里面，RSA的作用是<code>Key Transmission</code>，也就是说对称加密的密钥是由客户端生成，然后通过证书里面的公钥加密发送给服务端。如果采用的是RSA算法，那么这一步就不需要了。</li>
<li>TLS_DHE_XXXX。这类算法里面，使用<a href="https://zh.wikipedia.org/wiki/%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E5%AF%86%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="external">DH算法</a>进行密钥协商，DH的作用就是<code>Key Exchange</code>，密钥是由客户端和服务端共同生成的。</li>
</ol>
<p>DH密钥协商可以总结如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. &#36890;&#35759;&#21452;&#26041;&#65288;&#24352;&#19977;&#12289;&#26446;&#22235;&#65289;&#38656;&#35201;&#20808;&#32422;&#23450;&#22909;&#31639;&#27861;&#21442;&#25968;&#65288;algorithm parameters&#65289;&#65306;&#19968;&#20010;&#32032;&#25968; p &#20316;&#20026;&#27169;&#25968;&#65292;&#19968;&#20010;&#32032;&#25968; g &#20316;&#20026;&#22522;&#25968;&#65288;g &#20063;&#31216;&#20026;&#8220;&#29983;&#25104;&#20803;&#8221;&#65289;&#12290;&#36825;&#20004;&#20010;&#31639;&#27861;&#21442;&#25968;&#26159;&#21487;&#20197;&#23545;&#22806;&#20844;&#24320;&#28404;&#12290;&#10;2. &#23545;&#20110;&#24352;&#19977;&#32780;&#35328;&#65292;&#38656;&#35201;&#20808;&#24819;&#22909;&#19968;&#20010;&#31192;&#23494;&#30340;&#33258;&#28982;&#25968; a &#20316;&#20026;&#31169;&#38053;&#65288;&#19981;&#33021;&#20844;&#24320;&#65289;&#65292;&#28982;&#21518;&#35745;&#31639; A = ga mod p &#20316;&#20026;&#33258;&#24049;&#30340;&#20844;&#38053;&#65288;&#21487;&#20197;&#20844;&#24320;&#65289;&#12290;&#10;3. &#23545;&#26446;&#22235;&#32780;&#35328;&#20063;&#31867;&#20284;&#65292;&#20808;&#24819;&#22909;&#19968;&#20010;&#31192;&#23494;&#30340;&#33258;&#28982;&#25968; b &#20316;&#20026;&#31169;&#38053;&#65288;&#19981;&#33021;&#20844;&#24320;&#65289;&#65292;&#28982;&#21518;&#35745;&#31639; B = gb mod p &#20316;&#20026;&#33258;&#24049;&#30340;&#20844;&#38053;&#65288;&#21487;&#20197;&#20844;&#24320;&#65289;&#12290;&#10;4. &#24352;&#19977;&#21644;&#26446;&#22235;&#20114;&#30456;&#20132;&#25442;&#21508;&#33258;&#30340;&#20844;&#38053;&#12290;&#10;5. &#28982;&#21518;&#24352;&#19977;&#35745;&#31639;&#20986; k = Ba mod p&#65292;&#26446;&#22235;&#35745;&#31639;&#20986; k = Ab mod p</span><br></pre></td></tr></table></figure>
<p><img src="https://img.alicdn.com/imgextra/i1/99218453/TB2M7uCrYtlpuFjSspoXXbcDpXa_!!99218453.jpg" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#19978;&#22270;&#20013;&#65292;&#26381;&#21153;&#22120;&#31471;&#25226;p&#12289;g&#36824;&#26377;&#26381;&#21153;&#31471;&#31639;&#20986;&#30340;DH&#20844;&#38053;&#65292;&#32452;&#21512;&#25104;Pubkey&#65292;&#10;&#29992;SHA512&#27714;&#24471;hash&#20043;&#21518;&#65292;&#29992;&#26381;&#21153;&#31471;&#31169;&#38053;&#20570;RSA&#31614;&#21517;&#38450;&#20266;&#12290;&#10;&#10;&#23458;&#25143;&#31471;&#25910;&#21040;&#21518;&#65292;&#20250;&#29992;&#35777;&#20070;&#37324;&#38754;&#30340;&#20844;&#38053;&#35299;&#23494;&#65292;&#39564;&#35777;&#31614;&#21517;&#27491;&#30830;&#24615;&#65292;&#28982;&#21518;&#25343;&#20986;&#26381;&#21153;&#31471;DH&#20844;&#38053;</span><br></pre></td></tr></table></figure>
<h3 id="Client-Certificate-Request"><a href="#Client-Certificate-Request" class="headerlink" title="[Client Certificate Request]"></a>[Client Certificate Request]</h3><p>这一步也是可选的，要求客户端出示自己的证书，默认服务端不会向客户端索取证书。主要用于银行等金融领域，只有持有相应的证书（各类U盾）才允许客户端访问自己的网络，这里的客户端证书和CA证书类似，不过签发的一方通常是银行自己。</p>
<h3 id="Server-Done"><a href="#Server-Done" class="headerlink" title="Server Done"></a>Server Done</h3><p>这一步就是个标志位，告诉客户端，整个Server Hello阶段已经结束，轮到你回消息了。</p>
<p><img src="https://img.alicdn.com/imgextra/i2/99218453/TB2lVzdvEhnpuFjSZFEXXX0PFXa_!!99218453.png" alt=""></p>
<h3 id="Client-Certificate"><a href="#Client-Certificate" class="headerlink" title="Client Certificate"></a>Client Certificate</h3><p>如果Server Hello的时候，服务端要求验证客户端证书，客户端会在这里给服务端发送自己的证书。</p>
<p>这是客户端在Server Hello Done之后发送的第一条数据。</p>
<h3 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h3><p>这条消息必须在Client Certificate（如果有的话）之后立即发送。这里的<code>Key Exchange</code>交换的就是<code>pre-master key</code>，有了<code>pre-master key</code>和我们之前生成两个随机数<code>CR</code>和<code>SR</code>就能够计算出我们的对称加密的密钥了，这里总共分为两种情况：</p>
<ol>
<li>如果采用的是RSA算法，这里就是一个客户端产生的48 byte的随机数，用服务端的公钥加密之后发送。这里需要用公钥加密的原因在于，前两个随机数都是明文传输的，而采用RSA方式传输密钥，如果三个随机数都是明文，那么就可以计算出对称加密的密文了，所以这里一定是要加密传输。</li>
<li>如果采用的是DH算法及各种变种算法（如：ECDHE），这里发送的就是客户端公钥。这个消息不用公钥加密，原因在于DH算法本身的作用就是在不安全的通信通道交换一个安全的加密密钥，真是的一个神奇的算法。</li>
</ol>
<p><img src="https://img.alicdn.com/imgextra/i2/99218453/TB25GYpaRU4h1JjSZFLXXaFMpXa_!!99218453.png" alt=""></p>
<p><code>这里把DH算法的客户端公钥发送给服务端。</code></p>
<p>至于为什么不能全部都由客户端或者都由服务端生成呢？这里引用别的地方看到的一段话，解释得非常清楚：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#19981;&#31649;&#26159;&#23458;&#25143;&#31471;&#36824;&#26159;&#26381;&#21153;&#22120;&#65292;&#37117;&#38656;&#35201;&#38543;&#26426;&#25968;&#65292;&#36825;&#26679;&#29983;&#25104;&#30340;&#23494;&#38053;&#25165;&#19981;&#20250;&#27599;&#27425;&#37117;&#19968;&#26679;&#12290;&#10;&#30001;&#20110;SSL&#21327;&#35758;&#20013;&#35777;&#20070;&#26159;&#38745;&#24577;&#30340;&#65292;&#22240;&#27492;&#21313;&#20998;&#26377;&#24517;&#35201;&#24341;&#20837;&#19968;&#31181;&#38543;&#26426;&#22240;&#32032;&#26469;&#20445;&#35777;&#21327;&#21830;&#20986;&#26469;&#30340;&#23494;&#38053;&#30340;&#38543;&#26426;&#24615;&#12290;&#10;&#23545;&#20110;RSA&#23494;&#38053;&#20132;&#25442;&#31639;&#27861;&#26469;&#35828;&#65292;pre-master-key&#26412;&#36523;&#23601;&#26159;&#19968;&#20010;&#38543;&#26426;&#25968;&#65292;&#20877;&#21152;&#19978;hello&#28040;&#24687;&#20013;&#30340;&#38543;&#26426;&#65292;&#10;&#19977;&#20010;&#38543;&#26426;&#25968;&#36890;&#36807;&#19968;&#20010;&#23494;&#38053;&#23548;&#20986;&#22120;&#26368;&#32456;&#23548;&#20986;&#19968;&#20010;&#23545;&#31216;&#23494;&#38053;&#12290;&#10;&#10;pre master&#30340;&#23384;&#22312;&#22312;&#20110;SSL&#21327;&#35758;&#19981;&#20449;&#20219;&#27599;&#20010;&#20027;&#26426;&#37117;&#33021;&#20135;&#29983;&#23436;&#20840;&#38543;&#26426;&#30340;&#38543;&#26426;&#25968;&#65292;&#10;&#22914;&#26524;&#38543;&#26426;&#25968;&#19981;&#38543;&#26426;&#65292;&#37027;&#20040;pre master secret&#23601;&#26377;&#21487;&#33021;&#34987;&#29468;&#20986;&#26469;&#65292;&#10;&#37027;&#20040;&#20165;&#36866;&#29992;pre master secret&#20316;&#20026;&#23494;&#38053;&#23601;&#19981;&#21512;&#36866;&#20102;&#65292;&#22240;&#27492;&#24517;&#39035;&#24341;&#20837;&#26032;&#30340;&#38543;&#26426;&#22240;&#32032;&#65292;&#10;&#37027;&#20040;&#23458;&#25143;&#31471;&#21644;&#26381;&#21153;&#22120;&#21152;&#19978;pre master secret&#19977;&#20010;&#38543;&#26426;&#25968;&#19968;&#21516;&#29983;&#25104;&#30340;&#23494;&#38053;&#23601;&#19981;&#23481;&#26131;&#34987;&#29468;&#20986;&#20102;&#65292;&#10;&#19968;&#20010;&#20266;&#38543;&#26426;&#21487;&#33021;&#23436;&#20840;&#19981;&#38543;&#26426;&#65292;&#21487;&#26159;&#26159;&#19977;&#20010;&#20266;&#38543;&#26426;&#23601;&#21313;&#20998;&#25509;&#36817;&#38543;&#26426;&#20102;&#65292;&#10;&#27599;&#22686;&#21152;&#19968;&#20010;&#33258;&#30001;&#24230;&#65292;&#38543;&#26426;&#24615;&#22686;&#21152;&#30340;&#21487;&#19981;&#26159;&#19968;&#12290;</span><br></pre></td></tr></table></figure>
<p>总得来说即使客户端或者服务器端被人做了手脚，采用的随机数生成函数变成了可控的随机，那么只要另外一方不是被同一人做手脚，整体通信任然是安全的。</p>
<h3 id="Change-Cipher-Spec（客户端）"><a href="#Change-Cipher-Spec（客户端）" class="headerlink" title="Change Cipher Spec（客户端）"></a>Change Cipher Spec（客户端）</h3><p>这一步就是个标志位，告诉服务端：客户端之后通信就开始使用之前约定好的加密方式来加密传输了。</p>
<p><img src="https://img.alicdn.com/imgextra/i3/99218453/TB2B_4ZvOpnpuFjSZFIXXXh2VXa_!!99218453.png" alt=""></p>
<h3 id="Encrypted-Handshake-Message（客户端）"><a href="#Encrypted-Handshake-Message（客户端）" class="headerlink" title="Encrypted Handshake Message（客户端）"></a>Encrypted Handshake Message（客户端）</h3><p>这一步的作用是把之前握手的所有消息，用加密套件里的hash算法计算出一个值，然后用刚刚协商好的对称加密的密钥进行加密，发送给服务端，即能验证之前发送的消息有没有被篡改，又能验证下服务端计算的密钥对不对，如果计算不对就解不出明文。</p>
<p><img src="https://img.alicdn.com/imgextra/i3/99218453/TB2H4WzvH4npuFjSZFmXXXl4FXa_!!99218453.png" alt=""></p>
<p><code>因为内容已经加密了，就看不到具体的东西了</code></p>
<h3 id="Change-Cipher-Spec（服务端）"><a href="#Change-Cipher-Spec（服务端）" class="headerlink" title="Change Cipher Spec（服务端）"></a>Change Cipher Spec（服务端）</h3><p>跟客户端一样，一个标示位，告诉客户端：服务端之后通信就开始使用之前约定好的加密方式来加密传输了。</p>
<p><img src="https://img.alicdn.com/imgextra/i4/99218453/TB29x9gvNhmpuFjSZFyXXcLdFXa_!!99218453.png" alt=""></p>
<h3 id="Encrypted-Handshake-Message（服务端）"><a href="#Encrypted-Handshake-Message（服务端）" class="headerlink" title="Encrypted Handshake Message（服务端）"></a>Encrypted Handshake Message（服务端）</h3><p>同样的，把之前发送的所有东西都计算hash，然后用自己计算出来的对称加密密钥加密，发送给客户端解密。至此，服务端在握手阶段就结束了。客户端在收到消息，并且解密验证通过了之后，客户端也就结束了。</p>
<p><img src="https://img.alicdn.com/imgextra/i2/99218453/TB27tA8rYJkpuFjy1zcXXa5FFXa_!!99218453.png" alt=""></p>
<h2 id="TLS-数据传输"><a href="#TLS-数据传输" class="headerlink" title="TLS 数据传输"></a>TLS 数据传输</h2><p>总得来说跟HTTP差不多，只是在每个包后面添加了一个由报文认证信息码（MAC）算法计算出来的hash，保证信息传输的健全性。</p>
<p><img src="https://img.alicdn.com/imgextra/i4/99218453/TB2cw9EvH4npuFjSZFmXXXl4FXa_!!99218453.png" alt=""></p>
<p><code>数据传输协议的是http</code></p>
<h3 id="TLS-session-id"><a href="#TLS-session-id" class="headerlink" title="TLS session id"></a>TLS session id</h3><p>这个其实和SSO 登陆的cookie类似，有了cookie，第二次访问的时候服务端会去校验cookie是否有效，如果有效那就不用重新登陆了，如果cookie无效，那么就要重新登陆了。</p>
<p>session id也是如此，整个TLS握手过程还是比较复杂的，如果每个连接都这么握手一次，那体验也真是太差了，所以TLS设计了session id的概念，如果session id没有过期，那么就可以跳过握手阶段，直接开始加密传输。</p>
<p>所以有时候我们会发现，第一次访问某个HTTPS网站的时候很慢，但是第一次打开之后，第二次刷新，速度就很快了。</p>
<p>好了，到这里我们的TLS协议就介绍得差不多了，其实TLS协议还有非常多的细节，大家可以仔细参看<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="external">RFC文档</a>。TLS协议看起来似乎很完美，无法破解，但是现实中还是有很多基于TLS的攻击方式，下一篇就给大家来分享一下：</p>
<p><a href="">零门槛学习https–(5)常见的https攻击原理</a></p>

          
        
      </div>
      <footer>
        
          <div class="alignright">
            <a href="/2017/05/19/https-4/#more" class="more-link">Continue Reading<i class="fa fa-long-arrow-right fa-1"></i></a>
          </div>
        
        <div class="clearfix"></div>
      </footer>
    </div>
</article>





<nav id="pagination">
  
  
    <a href="/page/2/" class="alignright next">下一頁</a>
  
  <div class="clearfix"></div>
</nav></div></div>
    <aside id="sidebar" class="alignright"><div class="padding">
	
	  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜尋">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>
	
	  
<div class="widget recent-post">
  <h3 class="title">最新文章</h3>
  <ul class="entry">
    
      <li>
        <a href="/2018/06/23/strong-type-weak-type/">强类型？弱类型？强类型！</a>
      </li>
    
      <li>
        <a href="/2018/06/20/protocol-in-typescript/">在typescript中使用delegate来进行解耦</a>
      </li>
    
      <li>
        <a href="/2018/02/28/webpack-chunk-id-with-cdn/">webpack的chunk id和cdn缓存之间的爱恨情仇</a>
      </li>
    
      <li>
        <a href="/2018/01/19/typescript-skill/"></a>
      </li>
    
      <li>
        <a href="/2017/11/24/thinking-of-lazy-load/">最近对于懒加载的一些思考</a>
      </li>
    
  </ul>
</div>

	
	  
<div class="widget category">
  <h3 class="title">分類</h3>
  <ul class="entry">
  
    <li><a href="/categories/JavaScript/">JavaScript</a><small>2</small></li>
  
    <li><a href="/categories/Objective-C/">Objective-C</a><small>2</small></li>
  
    <li><a href="/categories/TypeScript/">TypeScript</a><small>1</small></li>
  
    <li><a href="/categories/basis/">basis</a><small>1</small></li>
  
    <li><a href="/categories/canvas/">canvas</a><small>1</small></li>
  
    <li><a href="/categories/coffee-script/">coffee-script</a><small>1</small></li>
  
    <li><a href="/categories/https/">https</a><small>5</small></li>
  
    <li><a href="/categories/iOS/">iOS</a><small>4</small></li>
  
    <li><a href="/categories/id2/">id2</a><small>7</small></li>
  
    <li><a href="/categories/mysql/">mysql</a><small>1</small></li>
  
    <li><a href="/categories/node/">node</a><small>1</small></li>
  
    <li><a href="/categories/physical/">physical</a><small>2</small></li>
  
    <li><a href="/categories/spider/">spider</a><small>1</small></li>
  
    <li><a href="/categories/typescript/">typescript</a><small>1</small></li>
  
    <li><a href="/categories/前端/">前端</a><small>1</small></li>
  
    <li><a href="/categories/计算机网络/">计算机网络</a><small>1</small></li>
  
  </ul>
</div>

	
	  
<div class="widget tag">
  <h3 class="title">標籤</h3>
  
    <a href="/tags/Google/">Google<small>1</small></a>
  
    <a href="/tags/JavaScript/">JavaScript<small>2</small></a>
  
    <a href="/tags/Javascript/">Javascript<small>1</small></a>
  
    <a href="/tags/OSX/">OSX<small>1</small></a>
  
    <a href="/tags/TypeScript/">TypeScript<small>1</small></a>
  
    <a href="/tags/adblock/">adblock<small>1</small></a>
  
    <a href="/tags/basic/">basic<small>1</small></a>
  
    <a href="/tags/bdd/">bdd<small>1</small></a>
  
    <a href="/tags/better-package/">better package<small>1</small></a>
  
    <a href="/tags/blog/">blog<small>1</small></a>
  
    <a href="/tags/browser/">browser<small>1</small></a>
  
    <a href="/tags/cache/">cache<small>1</small></a>
  
    <a href="/tags/canvas/">canvas<small>1</small></a>
  
    <a href="/tags/cdn/">cdn<small>1</small></a>
  
    <a href="/tags/chunkid/">chunkid<small>1</small></a>
  
    <a href="/tags/co/">co<small>1</small></a>
  
    <a href="/tags/cocoaTouch/">cocoaTouch<small>1</small></a>
  
    <a href="/tags/coffee-script/">coffee-script<small>1</small></a>
  
    <a href="/tags/complicating/">complicating<small>1</small></a>
  
    <a href="/tags/computer/">computer<small>1</small></a>
  
    <a href="/tags/coupling/">coupling<small>1</small></a>
  
    <a href="/tags/cover/">cover<small>1</small></a>
  
    <a href="/tags/dataplus/">dataplus<small>1</small></a>
  
    <a href="/tags/ddd/">ddd<small>1</small></a>
  
    <a href="/tags/decimal/">decimal<small>1</small></a>
  
    <a href="/tags/drive/">drive<small>1</small></a>
  
    <a href="/tags/emDrive/">emDrive<small>1</small></a>
  
    <a href="/tags/float/">float<small>1</small></a>
  
    <a href="/tags/freak/">freak<small>1</small></a>
  
    <a href="/tags/hexo/">hexo<small>2</small></a>
  
    <a href="/tags/high-precision/">high-precision<small>1</small></a>
  
    <a href="/tags/host/">host<small>1</small></a>
  
    <a href="/tags/http/">http<small>5</small></a>
  
    <a href="/tags/https/">https<small>5</small></a>
  
    <a href="/tags/iOS/">iOS<small>5</small></a>
  
    <a href="/tags/id2/">id2<small>1</small></a>
  
    <a href="/tags/javascript/">javascript<small>2</small></a>
  
    <a href="/tags/js/">js<small>1</small></a>
  
    <a href="/tags/json/">json<small>1</small></a>
  
    <a href="/tags/kaggle/">kaggle<small>1</small></a>
  
    <a href="/tags/knn/">knn<small>1</small></a>
  
    <a href="/tags/launchscreen/">launchscreen<small>1</small></a>
  
    <a href="/tags/lazyload/">lazyload<small>1</small></a>
  
    <a href="/tags/lock/">lock<small>1</small></a>
  
    <a href="/tags/mainHost/">mainHost<small>1</small></a>
  
    <a href="/tags/members/">members<small>1</small></a>
  
    <a href="/tags/microwave/">microwave<small>1</small></a>
  
    <a href="/tags/mtu/">mtu<small>1</small></a>
  
    <a href="/tags/mysql/">mysql<small>1</small></a>
  
    <a href="/tags/node/">node<small>3</small></a>
  
    <a href="/tags/number/">number<small>1</small></a>
  
    <a href="/tags/objective-c/">objective-c<small>2</small></a>
  
    <a href="/tags/package/">package<small>1</small></a>
  
    <a href="/tags/pai/">pai<small>1</small></a>
  
    <a href="/tags/physical/">physical<small>1</small></a>
  
    <a href="/tags/pixel/">pixel<small>1</small></a>
  
    <a href="/tags/poodle/">poodle<small>1</small></a>
  
    <a href="/tags/precision/">precision<small>1</small></a>
  
    <a href="/tags/protocol/">protocol<small>1</small></a>
  
    <a href="/tags/quantum/">quantum<small>1</small></a>
  
    <a href="/tags/reCAPTCHA/">reCAPTCHA<small>1</small></a>
  
    <a href="/tags/rsa/">rsa<small>4</small></a>
  
    <a href="/tags/setRootViewController/">setRootViewController<small>1</small></a>
  
    <a href="/tags/spider/">spider<small>1</small></a>
  
    <a href="/tags/tcp/">tcp<small>1</small></a>
  
    <a href="/tags/tcp-ip/">tcp/ip<small>1</small></a>
  
    <a href="/tags/tdd/">tdd<small>1</small></a>
  
    <a href="/tags/timer/">timer<small>1</small></a>
  
    <a href="/tags/tls/">tls<small>1</small></a>
  
    <a href="/tags/typescript/">typescript<small>1</small></a>
  
    <a href="/tags/unittest/">unittest<small>1</small></a>
  
    <a href="/tags/upload/">upload<small>1</small></a>
  
    <a href="/tags/uploadify/">uploadify<small>1</small></a>
  
    <a href="/tags/url/">url<small>1</small></a>
  
    <a href="/tags/web/">web<small>1</small></a>
  
    <a href="/tags/webpack/">webpack<small>1</small></a>
  
    <a href="/tags/yosemite/">yosemite<small>1</small></a>
  
    <a href="/tags/对称加密/">对称加密<small>4</small></a>
  
    <a href="/tags/扩展欧几里德/">扩展欧几里德<small>1</small></a>
  
    <a href="/tags/数字证书/">数字证书<small>3</small></a>
  
    <a href="/tags/欧拉函数/">欧拉函数<small>1</small></a>
  
    <a href="/tags/计算机网络/">计算机网络<small>1</small></a>
  
    <a href="/tags/踩过的iOS/">踩过的iOS<small>1</small></a>
  
</div>

	
</div></aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="padding">
	<div class="alignleft">
	  
	  &copy; 2018 PerterPon
	  
	  Powerd by <a href="http://hexo.io/" target="_blank">hexo</a>
	  and Theme by <a href="https://github.com/halfer53/metro-light" target="_blank">metro-light</a>
	</div>

	<div class="alignright">
		
		
			<a href="https://github.com/PerterPon" target="_blank" title="PerterPon Github"><i class="fa fa-github-square"></i></a>	
		
		
		
		
		
		
	</div>

	<div class="clearfix"></div>
</div>

<div class="scroll-top"><i class="fa fa-arrow-circle-up"></i></div>
<div>&nbsp;</div>
<div class="record">ICP证: 浙ICP备14031346号-1</div></footer>
  

 <script type="text/javascript">
var duoshuoQuery = {short_name:"perterpon"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = 'http://static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script>



<script src="//cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/3.0.4/jquery.imagesloaded.js"></script>
<script src="/js/gallery.js"></script>



<script type="text/javascript">
$(window).scroll(function() {

    if($(this).scrollTop() > 400) {
        $('.scroll-top').fadeIn(200);
    } else {
        $('.scroll-top').fadeOut(200);
    }
});

$('.scroll-top').bind('click', function(e) {
    e.preventDefault();
    $('body,html').animate({scrollTop:0},200);
});
</script>


<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F843c2a3226de23e0cfbb9668a390e06f' type='text/javascript'%3E%3C/script%3E"));
</script>
</body>
</html>
